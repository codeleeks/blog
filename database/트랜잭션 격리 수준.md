## SERIALIZABLE

동시성 지원 안 함.

트랜잭션 시작이 테이블 락과 같다.

## REPEATABLE READ

같은 트랜잭션 내 반복 조회의 결과가 같다.

레코드를 찾을 때 트랜잭션 id를 참고한다.
트랜잭션 id가 자신의 트랜잭션 id보다 작은 레코드를 찾는다.
트랜잭션 id란 트랜잭션 발생할 때마다 증가하는 값이기 때문에 자신의 트랜잭션 id보다 작은 트랜잭션 id를 갖는 레코드를 찾는다는 의미는 이후에 생기는 트랜잭션이 수정한 레코드를 무시하겠다는 뜻이다.

이후에 생기는 트랜잭션 때문에 팬텀 리드, non-repeatable read와 같은 동시성 문제가 발생하는데, REPEATABLE READ에서는 이를 회피할 수 있다.
non-repeatable read는 조건없이 회피가 가능한데, 팬텀 리드는 일반적으로 락을 걸지 않는 쿼리에 대해서 회피 가능하다. (MySQL은 락을 건 쿼리여도 회피가 가능하다)

<MessageBox title='MySQL의 락' level='info'>
  MySQL은 REPEATABLE READ 모드에서 락을 건 조회를 하면 넥스트 키 락을 건다.

  넥스트 키 락은 쿼리 조건에 해당하는 인덱스라면 현재 값이 들어 있든 아니든 락을 걸어버리는 것을 말한다.(레코드 락 + 갭락)

  쿼리 조건에 해당하는 범위에 있는 모든 레코드에 락을 걸어버리기 때문에, 다른 트랜잭션에서 해당 범위에 인서트 자체가 불가능하다.
  그래서 락을 건 쿼리는 팬텀 리드를 막을 수 있다.
</MessageBox>

## READ COMMITTED

커밋된 레코드를 조회한다.

커밋된 레코드만 조회하니까 합리적으로 보이지만, 트랜잭션 도중에 다른 트랜잭션의 커밋으로 인해 동시성 문제가 생길 수 있다.

non-repeatable read는 락을 건 쿼리에서 회피 가능하고, 팬텀 리드는 락을 걸든 안 걸든 근본적으로 회피가 불가능하다.

## READ UNCOMMITED

트랜잭션의 격리성이 아주 희미해진다.

한 트랜잭션의 커밋 이전 작업이 다른 트랜잭션에서 조회가 된다.

데이터 정합성 측면에서 문제가 될 수 있기 때문에, 일반적으로 추천되는 모드는 아니다.

## 요약

||SERIALIZABLE|REPEATABLE READ|READ COMMITED|READ UNCOMMITED|
|---|---|---|---|---|
|non-repeatable read|발생하지 않음|발생하지 않음|락 없는 쿼리에서 발생함|락 없는 쿼리에서 발생함|
|phantom read|발생하지 않음|락 있는 쿼리에서 발생함(MySQL은 발생하지 않음)|발생함|발생함|

## 참고

<a href='https://mangkyu.tistory.com/298' target='_blank'>스토리지 엔진의 락</a>
<br />
<a href='https://mangkyu.tistory.com/299' target='_blank'>트랜잭션 격리 수준</a>
