## MySQL의 락

공유락과 배타락이 있다.

공유락은 읽기를 위한 락이다. 읽기 위한 레코드 접근은 허용하지만, 쓰기 위한 레코드 접근은 불허한다.

배타락은 좀 더 막강한 락이다. 읽기든 쓰기든 선점한 레코드에 대한 접근을 허용하지 않는다. 쓰기를 위한 락인 셈이다.

공유락은 S로 표현되고(Shared), 배타락은 X로 표현된다(eXclusive).

### Intention Lock

Intention Lock은 테이블락이다. IS와 IX가 있다.
S와 X 락은 row 락이다. 
row 락을 얻기 위해선 먼저 테이블락을 얻어야 한다.
row를 수정하다가 DROP TABLE, ALTER TABLE과 같은 테이블 자체를 수정하는 쿼리와의 동시성 문제가 발생할 수 있기 때문이다.
그래서 Intention Lock이 필요하다.

IX와 IS끼리는 blocking하지 않는다. 실제 X나 S로 락을 잡으려 할 때 같은 row라면 blocking을 한다.

![image](https://github.com/user-attachments/assets/62608a49-c3a8-42b8-9dd1-a9077470a41d)

참고
- https://stackoverflow.com/questions/25903764/why-is-an-ix-lock-compatible-with-another-ix-lock-in-innodb
- https://rosebud90.tistory.com/entry/InoDB-%EC%9E%A0%EA%B8%88-1-S%EB%9D%BD-X%EB%9D%BD-IS%EB%9D%BD-IX%EB%9D%BD?pidx=0


## 워크벤치에서 트랜잭션 오토커밋 해제하기

MySQL의 워크벤치는 쿼리탭에 쿼리를 적고 실행하면 자동으로 커밋한다.

동시성 동작을 확인하려면 오토커밋 기능을 꺼야 한다.

![image](https://github.com/user-attachments/assets/0a9af211-8a20-471a-9f0b-6d49f9b3c343)

## 워크벤치에서 트랜잭션 분리하기

MySQL 워크벤치는 '연결' 단위로 트랜잭션이 분리된다.

같은 연결에서 쿼리탭을 분리한다고 해서 트랜잭션이 분리되지 않는다. 각 쿼리탭에서 수행되는 쿼리는 같은 트랜잭션을 공유한다.

현재 연결을 복제하여 새 연결을 생성하려면 `ctrl + shift + t`를 누르면 된다.

## 락 상태 확인하기

MySQL(innodb)의 락 상태를 확인하려면 글로벌 변수 설정이 필요하다. 

```sql
SET GLOBAL innodb_status_output=ON;
SET GLOBAL innodb_status_output_locks=ON;
```

그리고 innodb의 status를 확인한다.

```sql
show engine innodb status
```

그러면 아래와 같이 어떤 테이블 어떤 필드에 대한 어떤 종류의 락이 걸려 있는지 확인할 수 있다.

![image](https://github.com/user-attachments/assets/7c09de3f-242e-4351-8562-38ae01f72815)

참고
- https://dev.mysql.com/doc/refman/5.7/en/innodb-enabling-monitors.html

## 외래키 제약 조건은 S락을 건다.

두 개의 트랜잭션에서 아래와 같은 쿼리를 실행하면 데드락이 발생한다.

```sql
-- TX1
begin;
insert into child values (1, 'child', 1);
update parent set updated_at = now() where id = 1;

-- TX2
begin;
insert into child values (2, 'child', 1);
update parent set updated_at = now() where id = 1;
```

child 테이블에 레코드를 삽입하는 쿼리는 parent에는 S락을 child에는 X락을 건다.
parent 테이블의 레코드를 수정하는 쿼리는 parent에 X락을 건다.

TX1에서 삽입, TX2에서 삽입, TX1에서 수정, TX2에서 수정했다고 하자.

1. TX1의 삽입: parent 테이블에 대한 S락, child 테이블에 대한 X락 -> 모두 획득
2. TX2의 삽입: parent 테이블에 대한 S락, child 테이블에 대한 X락 -> 모두 획득
3. TX1의 수정: parent 테이블에 대한 X락 -> X락 대기(TX2 S락의 해제를 기다림)
4. TX2의 수정: parent 테이블에 대한 X락 -> X락 대기(TX1 S락의 해제를 기다림)

결국 TX1과 TX2는 서로 락이 해제되기를 기다리므로, 데드락이다.


