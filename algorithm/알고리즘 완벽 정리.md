---
summary: 알고리즘 문제 풀이를 위한 알고리즘 기법을 정리한다
date: 2024-08-05
title-image: 'https://raw.githubusercontent.com/codeleeks/blog/codeleeks-images/algorithm/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EC%99%84%EB%B2%BD%20%EC%A0%95%EB%A6%AC/title.png'
---

## 이진 탐색

정렬된 리스트에서 탐색 범위를 반으로 줄여가며 탐색.

정렬된 리스트이기 때문에 반으로 줄여가며 탐색할 수 있고, 반으로 탐색할 수 있기 때문에 탐색 시간이 log 단위로 떨어짐.

```java
//재귀
int biSearch2(int arr[], int left, int right, int key) {
  if (left > right) return -1;

  int mid = (left + right) / 2;
  if (arr[mid] < key) {
    left = mid + 1;
  } else if (arr[mid] > key) {
    right = mid;
  } else {
    return mid;
  }
  return biSearch2(arr, left, right, key);
}

//반복문
int biSearch(int arr[], int left, int  right, int key) {

  while(left<=right) {
    int mid = (left + right) / 2;

    if (arr[mid] < key) {
      left = mid + 1;
    } else if (arr[mid] > key) {
      right = mid;
    } else {
      return mid;
    }
  }

  return -1;
}
```

## 퀵 정렬

피봇을 기준으로 오른쪽에 큰 값, 왼쪽에 작은 값을 "최대한" 배치하려는 정렬.

"최대한"이라서 한 번에 되지는 않는다.

전체 구간에 대해 피봇을 정해서 한 번의 정렬을 끝내고, 피봇의 왼쪽 구간, 오른쪽 구간에 대해서도 각각 재귀적으로 피봇을 잡아 정렬한다.

이렇게 재귀적으로 가게 되면 구간이 작아지는데, 구간이 1일 때는 비로소 정렬의 완벽성을 보장할 수 있다.

구간이 1일 때까지 정렬을 마치 그 순간 전체 구간에 대한 정렬이 완성된다.

### 시간 복잡도

nlogn 인데, 피봇을 어떻게 잡느냐에 따라 다르다.

결국 퀵소트가 로그 시간으로 떨어지는 이유는 피봇이 중간값이기 때문이다.

피봇을 기준으로 오른쪽에 큰 값, 왼쪽에 작은 값을 배치하면, 결국 피봇은 정렬된 리스트에서의 자기 자리와 근접한 위치로 가게 된다.

이 때, 피봇이 중간값이면 정렬된 리스트에서의 자기 자리를 기준으로 왼쪽과 오른쪽으로 다음 구간을 나누기 때문에, 각 구간은 거의 절반의 크기로 쪼개진다.

그런데 피봇이 양극단의 값(최댓값 혹은 최솟값)이면 정렬된 리스트에서의 자기 자리가 양극단이기 때문에, 한 쪽 구간이 크고 다른 한 쪽 구간은 작게 쪼개진다.

그래서 로그 시간으로 떨어지지 않고, n^2에 근접한다.

방법은 피봇을 랜덤하게 잡는 것이다.

![image](https://github.com/user-attachments/assets/2ce9736f-d1ae-4ac1-9c45-db7732d3b94b)

피봇을 어떻게 잡느냐에 따라 [BOJ2751](https://www.acmicpc.net/problem/2751) 문제처럼 통과되기도 하고 아니기도 한다.

### 코드

```java
package algorithm.java.sort;

import java.util.Arrays;

public class QuickSort {
    private int arr[];

    public QuickSort(int[] arr) {
        this.arr = Arrays.copyOf(arr, arr.length);
    }

    public int[] getArr() {
        return arr;
    }

    public void sort() {
        _sort(0, arr.length - 1, arr);
    }

    private int pivot(int start, int end) {
        return (int) (Math.random() * (end - start + 1) + start);
    }

    private void _sort(int start, int end, int[] arr) {
        if (start >= end) {
            return;
        }

        int pivot = arr[pivot(start, end)];
        int left = start;
        int right = end;

        while(left <= right) {
            while(arr[left] < pivot) left++;
            while(arr[right] > pivot) right--;

            if(left <= right) {
                int tmp = arr[left];
                arr[left] = arr[right];
                arr[right] = tmp;

                left += 1;
                right -= 1;
            }
        }

        if (start < right) {
            _sort(start, right, arr);
        }
        if (left < end) {
            _sort(left, end, arr);
        }
    }
}
```

## 머지 소트

원본 배열을 부분 리스트로 쪼개고, 두 개의 부분리스트를 짝을 지어 부분리스트 간 값 비교를 통해 정렬한다.

가장 작은 부분리스트(길이가 1, 즉 요소 1개) 간 정렬을 완료하면 길이가 2인 부분리스트를 구하고 그 부분리스트 간의 정렬을 진행한다.

결과적으로 전체리스트가 정렬된다.

시간복잡도는 nlogn이며, 구현 과정에서 정렬된 리스트를 담을 배열이 하나 필요하기 때문에 공간복잡도 n이 요구된다.

퀵소트는 피봇을 어떻게 잡느냐에 따라 시간복잡도가 달라지지만, 머지소트는 비교적 stable한 성능을 보인다.

### 코드

```java
package algorithm.java.sort;

import java.util.Arrays;

public class MergeSort {
    private int[] arr;

    public MergeSort(int[] arr) {
        this.arr = Arrays.copyOf(arr, arr.length);
    }

    public int[] getArr() {
        return arr;
    }

    public void sort() {
        mergeSort(0, arr.length - 1, arr);
    }

    protected void mergeSort(int start, int end, int[] arr) {
        int length = arr.length;
        int sorted[] = Arrays.copyOf(arr, length);
        //부분리스트의 사이즈를 2배씩 늘려간다. 1 -> 2 -> 4 -> 8...
        for(int size = 1; size < length; size <<= 1) {
            //ls = left sublist start index.
            //le = left sublist end index.
            //rs = right sublist start index.
            //re = right sublist end index.
            //두 개의 부분리스트를 구한다. 구한다는 것은 각 부분리스트의 처음과 끝 index를 구한다는 것이다.
            for(int ls = 0; ls + size <= end; ls+=(size<<1)) {
                int le = ls + size-1;
                int rs = le + 1;
                int re = Math.min(rs + size-1, end);

                merge(ls, le, rs, re, arr, sorted);
            }
        }
    }

    //두 부분 리스트 간 값 비교를 통해 정렬한다.
    protected void merge(int ls, int le, int rs, int re, int[] arr, int[] sorted) {
        int li = ls;
        int ri = rs;
        int si = 0;

        while(li <= le && ri <= re) {
            if (arr[li] <= arr[ri]) {
                sorted[si++] = arr[li++];
            } else {
                sorted[si++] = arr[ri++];
            }
        }

        if (li <= le) {
            while(li <= le) {
                sorted[si++] = arr[li++];
            }
        } else {
            while(ri <= re) {
                sorted[si++] = arr[ri++];
            }
        }

        for (int i = 0; i < si; i++) {
            arr[i + ls] = sorted[i];
        }
    }
}

```

## 카운팅 정렬

요소값의 빈도수를 작은 수부터 누적하면 정렬된 순서가 된다.

1, 1, 3, 5, 9, 11 에서 1은 0, 1번째, 3은 2번째(1이 두 번 나왔으므로), 5는 2+1 번째 (1이 두 번, 3이 1번 나왔으므로)와 같이 빈도수의 누적합은 정렬된 순서를 의미한다.

시간 복잡도는 n인 가장 성능이 좋은 알고리즘이지만, 요소값의 범위가 크면 카운팅 배열이 비효율적으로 커진다는 치명적인 단점이 있다.
예를 들어, 숫자 10개를 정렬하는데, 숫자의 범위가 -1억부터 1억이라면 카운팅 배열은 2억 길이를 가져야 한다.

그래서 정렬할 수의 범위가 적을 때 쓰는 게 유리하다.

### 코드

```java
package algorithm.java.sort;

import java.util.Arrays;
import java.util.List;
import java.util.OptionalInt;

public class CountingSort {
    private int[] arr;

    public CountingSort(int[] arr) {
        this.arr = Arrays.copyOf(arr, arr.length);
    }

    public int[] getArr() {
        return arr;
    }

    protected int min(int arr[]) {
        return Arrays.stream(arr).min().getAsInt();
    }

    protected int max(int arr[]) {
        return Arrays.stream(arr).max().getAsInt();
    }

//    0~111 수만 허용
    public void sort() {
        if (max(arr) > 1000000 || min(arr) < 0) {
            System.out.println("정렬 불가. 허용되는 수 범위는 0~111");
            return;
        }
        countingSort(arr);
    }

    protected void countingSort(int[] arr) {
        int length = arr.length;
        int count[] = new int[1000001];
        int sorted[] = new int[length];
        int maxValue = max(arr);
        for (int i = 0; i < length; i++) {
            count[arr[i]] += 1;
        }

        for (int i = 1; i <= maxValue; i++) {
            count[i] += count[i-1];
        }

        for (int i = length-1; i >= 0; i--) {
            sorted[--count[arr[i]]] = arr[i];
        }

        for (int i = 0; i < length; i++) {
            arr[i] = sorted[i];
        }
    }
}
```

요소값이 중복되지 않는다면 누적합을 구할 필요도 없다.

그냥 카운팅 배열을 순회하면서 값이 있는 경우에 정렬될 배열에 복사하면 된다.

[BOJ2751](https://www.acmicpc.net/problem/2751) 문제 풀이 코드를 참고하자.

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.valueOf(bf.readLine());
        int buffer = 1000000;
        int arr[] = new int[N];
        int count[] = new int[(buffer << 1) + 1];
        
        for(int i = 0; i < N; i++) {
           // 음수값 처리. 출력할 때 원본으로 돌리기 위해 buffer만큼 빼준다.
            arr[i] = Integer.valueOf(bf.readLine()) + buffer;
            count[arr[i]] += 1;
        }

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < count.length; i++) {
            if (count[i] == 1) {
                sb.append(i-buffer).append("\n");
            }
        }
        System.out.println(sb.toString());
    }
}
```
