## 이진 탐색

정렬된 리스트에서 탐색 범위를 반으로 줄여가며 탐색.

정렬된 리스트이기 때문에 반으로 줄여가며 탐색할 수 있고, 반으로 탐색할 수 있기 때문에 탐색 시간이 log 단위로 떨어짐.

```java
//재귀
int biSearch2(int arr[], int left, int right, int key) {
  if (left > right) return -1;

  int mid = (left + right) / 2;
  if (arr[mid] < key) {
    left = mid + 1;
  } else if (arr[mid] > key) {
    right = mid;
  } else {
    return mid;
  }
  return biSearch2(arr, left, right, key);
}

//반복문
int biSearch(int arr[], int left, int  right, int key) {

  while(left<=right) {
    int mid = (left + right) / 2;

    if (arr[mid] < key) {
      left = mid + 1;
    } else if (arr[mid] > key) {
      right = mid;
    } else {
      return mid;
    }
  }

  return -1;
}
```

## 퀵 정렬

피봇을 기준으로 오른쪽에 큰 값, 왼쪽에 작은 값을 "최대한" 배치하려는 정렬.

"최대한"이라서 한 번에 되지는 않는다.

전체 구간에 대해 피봇을 정해서 한 번의 정렬을 끝내고, 피봇의 왼쪽 구간, 오른쪽 구간에 대해서도 각각 재귀적으로 피봇을 잡아 정렬한다.

이렇게 재귀적으로 가게 되면 구간이 작아지는데, 구간이 1일 때는 비로소 정렬의 완벽성을 보장할 수 있다.

구간이 1일 때까지 정렬을 마치 그 순간 전체 구간에 대한 정렬이 완성된다.

### 시간 복잡도

nlogn 인데, 피봇을 어떻게 잡느냐에 따라 다르다.

결국 퀵소트가 로그 시간으로 떨어지는 이유는 피봇이 중간값이기 때문이다.

피봇을 기준으로 오른쪽에 큰 값, 왼쪽에 작은 값을 배치하면, 결국 피봇은 정렬된 리스트에서의 자기 자리와 근접한 위치로 가게 된다.

이 때, 피봇이 중간값이면 정렬된 리스트에서의 자기 자리를 기준으로 왼쪽과 오른쪽으로 다음 구간을 나누기 때문에, 각 구간은 거의 절반의 크기로 쪼개진다.

그런데 피봇이 양극단의 값(최댓값 혹은 최솟값)이면 정렬된 리스트에서의 자기 자리가 양극단이기 때문에, 한 쪽 구간이 크고 다른 한 쪽 구간은 작게 쪼개진다.

그래서 로그 시간으로 떨어지지 않고, n^2에 근접한다.

방법은 피봇을 랜덤하게 잡는 것이다.

![image](https://github.com/user-attachments/assets/2ce9736f-d1ae-4ac1-9c45-db7732d3b94b)

피봇을 어떻게 잡느냐에 따라 [BOJ2751](https://www.acmicpc.net/problem/2751) 문제처럼 통과되기도 하고 아니기도 한다.

### 코드

```java
package algorithm.java.sort;

import java.util.Arrays;

public class QuickSort {
    private int arr[];

    public QuickSort(int[] arr) {
        this.arr = Arrays.copyOf(arr, arr.length);
    }

    public int[] getArr() {
        return arr;
    }

    public void sort() {
        _sort(0, arr.length - 1, arr);
    }

    private int pivot(int start, int end) {
        return (int) (Math.random() * (end - start + 1) + start);
    }

    private void _sort(int start, int end, int[] arr) {
        if (start >= end) {
            return;
        }

        int pivot = arr[pivot(start, end)];
        int left = start;
        int right = end;

        while(left <= right) {
            while(arr[left] < pivot) left++;
            while(arr[right] > pivot) right--;

            if(left <= right) {
                int tmp = arr[left];
                arr[left] = arr[right];
                arr[right] = tmp;

                left += 1;
                right -= 1;
            }
        }

        if (start < right) {
            _sort(start, right, arr);
        }
        if (left < end) {
            _sort(left, end, arr);
        }
    }
}
```

## 머지 소트

원본 배열을 부분 리스트로 쪼개고, 두 개의 부분리스트를 짝을 지어 부분리스트 간 값 비교를 통해 정렬한다.

가장 작은 부분리스트(길이가 1, 즉 요소 1개) 간 정렬을 완료하면 길이가 2인 부분리스트를 구하고 그 부분리스트 간의 정렬을 진행한다.

결과적으로 전체리스트가 정렬된다.

시간복잡도는 nlogn이며, 구현 과정에서 정렬된 리스트를 담을 배열이 하나 필요하기 때문에 공간복잡도 n이 요구된다.

퀵소트는 피봇을 어떻게 잡느냐에 따라 시간복잡도가 달라지지만, 머지소트는 비교적 stable한 성능을 보인다.

### 코드

```java
package algorithm.java.sort;

import java.util.Arrays;

public class MergeSort {
    private int[] arr;

    public MergeSort(int[] arr) {
        this.arr = Arrays.copyOf(arr, arr.length);
    }

    public int[] getArr() {
        return arr;
    }

    public void sort() {
        mergeSort(0, arr.length - 1, arr);
    }

    protected void mergeSort(int start, int end, int[] arr) {
        int length = arr.length;
        int sorted[] = Arrays.copyOf(arr, length);
        //부분리스트의 사이즈를 2배씩 늘려간다. 1 -> 2 -> 4 -> 8...
        for(int size = 1; size < length; size <<= 1) {
            //ls = left sublist start index.
            //le = left sublist end index.
            //rs = right sublist start index.
            //re = right sublist end index.
            //두 개의 부분리스트를 구한다. 구한다는 것은 각 부분리스트의 처음과 끝 index를 구한다는 것이다.
            for(int ls = 0; ls + size <= end; ls+=(size<<1)) {
                int le = ls + size-1;
                int rs = le + 1;
                int re = Math.min(rs + size-1, end);

                merge(ls, le, rs, re, arr, sorted);
            }
        }
    }

    //두 부분 리스트 간 값 비교를 통해 정렬한다.
    protected void merge(int ls, int le, int rs, int re, int[] arr, int[] sorted) {
        int li = ls;
        int ri = rs;
        int si = 0;

        while(li <= le && ri <= re) {
            if (arr[li] <= arr[ri]) {
                sorted[si++] = arr[li++];
            } else {
                sorted[si++] = arr[ri++];
            }
        }

        if (li <= le) {
            while(li <= le) {
                sorted[si++] = arr[li++];
            }
        } else {
            while(ri <= re) {
                sorted[si++] = arr[ri++];
            }
        }

        for (int i = 0; i < si; i++) {
            arr[i + ls] = sorted[i];
        }
    }
}

```
