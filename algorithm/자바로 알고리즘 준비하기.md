## BOJ 제출 샘플

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Main {

	public static void main(String[] args) throws IOException {
	   System.out.println("Hello World!"); 
	}
}
```

- 패키지 명시 없음에 주의
- 클래스는 Main으로 고정

## 입력과 출력

```java
import java.io.*;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Main {

    public static void main(String[] args) throws IOException {
//        System.setIn(new FileInputStream("input.txt"));
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(bf.readLine());
        long[] arr = new long[N];

        StringTokenizer stringTokenizer = new StringTokenizer(bf.readLine());
        for (int i = 0; i < N; i++) {
            long d = Long.parseLong(stringTokenizer.nextToken());
            arr[i] = d;
        }

        Arrays.sort(arr);

        int M = Integer.parseInt(bf.readLine());
        stringTokenizer = new StringTokenizer(bf.readLine());

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < M; i++) {
            long key = Long.parseLong(stringTokenizer.nextToken());
            long found = Arrays.binarySearch(arr, key);
            if (found >= 0) {
                sb.append(1).append("\n");
            } else {
                sb.append(0).append("\n");
            }
        }

        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        bw.write(sb.toString());
        bw.close();
    }
}      
```

- `BufferedReader`로 인풋 처리 속도 증가
- `BufferedWriter`로 아웃풋 처리 속도 증가
- `StringTokenizer`로 공백 구분 인풋 처리
- `StringBuilder`로 문자열 합성 처리
- `System.setIn`으로 파일에서 인풋을 받음
- string -> int는 `Integer.parseInt()`

`input.txt`는 프로젝트 루트에 존재
![image](https://github.com/user-attachments/assets/6b0a3250-4db7-4150-a8e4-61e032e6c1ad)


## 배열

```java
//정렬
long[] arr = new long[N];
Arrays.sort(arr);

//바이너리 서치
long found = Arrays.binarySearch(arr, key);
if (found >= 0) {
    sb.append(1).append("\n");
} else {
    sb.append(0).append("\n");
}
```

## lower_bound / upper_bound

이분 탐색을 이용하여 어떤 리스트(배열)에서 특정 값을 찾을 때, 중복되는 값을 가지고 있을 수 있다. 그 중복값이 몇 개가 있는지 찾는 문제를 해결하기 위해 upper_bound 와 lower_bound가 존재한다.

![image](https://github.com/user-attachments/assets/49b6e172-e02b-4bd6-b68d-35834d9331c2)

[참고](https://velog.io/@layl__a/%EC%9D%B4%EB%B6%84%ED%83%90%EC%83%89-upperbound%EC%99%80-lowerbound-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0)

자바 표준 라이브러리에서 제공하는 것은 없고 직접 구현해야 한다.

```java
private static int lowerBound(long arr[], long key) {
    int l = 0, r = arr.length;

    while (l < r) {
        int mid = (l + r) / 2;
        if (arr[mid] >= key) {
            r = mid;
        } else {
            l = mid + 1;
        }
    }

    return r;
}

private static int upperBound(long arr[], long key) {
    int l = 0, r = arr.length;

    while (l < r) {
        int mid = (l + r) / 2;
        if (arr[mid] <= key) {
            l = mid + 1;
        } else {
            r = mid;
        }
    }

    return l;
}
```

- r은 arr.length로 해야 함을 주의 (최댓값이 키인 경우 반복문 조건인 `l < r`을 만족하려면 r이 arr.length여야 함)
- =을 어디에 둘 것인지가 포인트. lower_bound는 같아도 왼쪽으로 가야 하고, upper_bound는 같아도 오른쪽으로 가야 한다.
