## BOJ 제출 샘플

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Main {

	public static void main(String[] args) throws IOException {
	   System.out.println("Hello World!"); 
	}
}
```

- 패키지 명시 없음에 주의
- 클래스는 Main으로 고정

## 입력과 출력

```java
import java.io.*;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Main {

    public static void main(String[] args) throws IOException {
//        System.setIn(new FileInputStream("input.txt"));
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(bf.readLine());
        long[] arr = new long[N];

        StringTokenizer stringTokenizer = new StringTokenizer(bf.readLine());
        for (int i = 0; i < N; i++) {
            long d = Long.parseLong(stringTokenizer.nextToken());
            arr[i] = d;
        }

        Arrays.sort(arr);

        int M = Integer.parseInt(bf.readLine());
        stringTokenizer = new StringTokenizer(bf.readLine());

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < M; i++) {
            long key = Long.parseLong(stringTokenizer.nextToken());
            long found = Arrays.binarySearch(arr, key);
            if (found >= 0) {
                sb.append(1).append("\n");
            } else {
                sb.append(0).append("\n");
            }
        }

        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        bw.write(sb.toString());
        bw.close();
    }
}      
```

- `BufferedReader`로 인풋 처리 속도 증가
- `BufferedWriter`로 아웃풋 처리 속도 증가
- `StringTokenizer`로 공백 구분 인풋 처리
- `StringBuilder`로 문자열 합성 처리
- `System.setIn`으로 파일에서 인풋을 받음
- string -> int는 `Integer.parseInt()`

`input.txt`는 프로젝트 루트에 존재
![image](https://github.com/user-attachments/assets/6b0a3250-4db7-4150-a8e4-61e032e6c1ad)


## 배열

```java
//정렬
long[] arr = new long[N];
Arrays.sort(arr);

//바이너리 서치
long found = Arrays.binarySearch(arr, key);
if (found >= 0) {
    sb.append(1).append("\n");
} else {
    sb.append(0).append("\n");
}
```

## 이진 탐색

정렬된 리스트에서 탐색 범위를 반으로 줄여가며 탐색.

정렬된 리스트이기 때문에 반으로 줄여가며 탐색할 수 있고, 반으로 탐색할 수 있기 때문에 탐색 시간이 log 단위로 떨어짐.

```java
//재귀
int biSearch2(int arr[], int left, int right, int key) {
  if (left > right) return -1;

  int mid = (left + right) / 2;
  if (arr[mid] < key) {
    left = mid + 1;
  } else if (arr[mid] > key) {
    right = mid;
  } else {
    return mid;
  }
  return biSearch2(arr, left, right, key);
}

//반복문
int biSearch(int arr[], int left, int  right, int key) {

  while(left<=right) {
    int mid = (left + right) / 2;

    if (arr[mid] < key) {
      left = mid + 1;
    } else if (arr[mid] > key) {
      right = mid;
    } else {
      return mid;
    }
  }

  return -1;
}
```

라이브러리에서도 지원하고 있다.

```java
int key = 1;
int found = Arrays.sort(arr, key);
if (found < 0) {
	//못찾음.
} else {
	// 찾음. 인덱스 리턴. 동일값이 여러 개일 때는 먼저 찾은 인덱스 리턴.
}
```

## 퀵 정렬

피봇을 기준으로 오른쪽에 큰 값, 왼쪽에 작은 값을 "최대한" 배치하려는 정렬.

"최대한"이라서 한 번에 되지는 않는다.

전체 구간에 대해 피봇을 정해서 한 번의 정렬을 끝내고, 피봇의 왼쪽 구간, 오른쪽 구간에 대해서도 각각 재귀적으로 피봇을 잡아 정렬한다.

이렇게 재귀적으로 가게 되면 구간이 작아지는데, 구간이 1일 때는 비로소 정렬의 완벽성을 보장할 수 있다.

구간이 1일 때까지 정렬을 마치 그 순간 전체 구간에 대한 정렬이 완성된다.

### 시간 복잡도

nlogn 인데, 피봇을 어떻게 잡느냐에 따라 다르다.

결국 퀵소트가 로그 시간으로 떨어지는 이유는 피봇이 중간값이기 때문이다.

피봇을 기준으로 오른쪽에 큰 값, 왼쪽에 작은 값을 배치하면, 결국 피봇은 정렬된 리스트에서의 자기 자리와 근접한 위치로 가게 된다.

이 때, 피봇이 중간값이면 정렬된 리스트에서의 자기 자리를 기준으로 왼쪽과 오른쪽으로 다음 구간을 나누기 때문에, 각 구간은 거의 절반의 크기로 쪼개진다.

그런데 피봇이 양극단의 값(최댓값 혹은 최솟값)이면 정렬된 리스트에서의 자기 자리가 양극단이기 때문에, 한 쪽 구간이 크고 다른 한 쪽 구간은 작게 쪼개진다.

그래서 로그 시간으로 떨어지지 않고, n^2에 근접한다.

방법은 피봇을 랜덤하게 잡는 것이다.

![image](https://github.com/user-attachments/assets/2ce9736f-d1ae-4ac1-9c45-db7732d3b94b)

피봇을 어떻게 잡느냐에 따라 [BOJ2751](https://www.acmicpc.net/problem/2751) 문제처럼 통과되기도 하고 아니기도 한다.

### 코드

```java
package algorithm.java.sort;

import java.util.Arrays;

public class QuickSort {
    private int arr[];

    public QuickSort(int[] arr) {
        this.arr = Arrays.copyOf(arr, arr.length);
    }

    public int[] getArr() {
        return arr;
    }

    public void sort() {
        _sort(0, arr.length - 1, arr);
    }

    private int pivot(int start, int end) {
        return (int) (Math.random() * (end - start + 1) + start);
    }

    private void _sort(int start, int end, int[] arr) {
        if (start >= end) {
            return;
        }

        int pivot = arr[pivot(start, end)];
        int left = start;
        int right = end;

        while(left <= right) {
            while(arr[left] < pivot) left++;
            while(arr[right] > pivot) right--;

            if(left <= right) {
                int tmp = arr[left];
                arr[left] = arr[right];
                arr[right] = tmp;

                left += 1;
                right -= 1;
            }
        }

        if (start < right) {
            _sort(start, right, arr);
        }
        if (left < end) {
            _sort(left, end, arr);
        }
    }
}
```

## 머지 소트

원본 배열을 부분 리스트로 쪼개고, 두 개의 부분리스트를 짝을 지어 부분리스트 간 값 비교를 통해 정렬한다.

가장 작은 부분리스트(길이가 1, 즉 요소 1개) 간 정렬을 완료하면 길이가 2인 부분리스트를 구하고 그 부분리스트 간의 정렬을 진행한다.

결과적으로 전체리스트가 정렬된다.

시간복잡도는 nlogn이며, 구현 과정에서 정렬된 리스트를 담을 배열이 하나 필요하기 때문에 공간복잡도 n이 요구된다.

퀵소트는 피봇을 어떻게 잡느냐에 따라 시간복잡도가 달라지지만, 머지소트는 비교적 stable한 성능을 보인다.

### 코드

```java
package algorithm.java.sort;

import java.util.Arrays;

public class MergeSort {
    private int[] arr;

    public MergeSort(int[] arr) {
        this.arr = Arrays.copyOf(arr, arr.length);
    }

    public int[] getArr() {
        return arr;
    }

    public void sort() {
        mergeSort(0, arr.length - 1, arr);
    }

    protected void mergeSort(int start, int end, int[] arr) {
        int length = arr.length;
        int sorted[] = Arrays.copyOf(arr, length);
        //부분리스트의 사이즈를 2배씩 늘려간다. 1 -> 2 -> 4 -> 8...
        for(int size = 1; size < length; size <<= 1) {
            //ls = left sublist start index.
            //le = left sublist end index.
            //rs = right sublist start index.
            //re = right sublist end index.
            //두 개의 부분리스트를 구한다. 구한다는 것은 각 부분리스트의 처음과 끝 index를 구한다는 것이다.
            for(int ls = 0; ls + size <= end; ls+=(size<<1)) {
                int le = ls + size-1;
                int rs = le + 1;
                int re = Math.min(rs + size-1, end);

                merge(ls, le, rs, re, arr, sorted);
            }
        }
    }

    //두 부분 리스트 간 값 비교를 통해 정렬한다.
    protected void merge(int ls, int le, int rs, int re, int[] arr, int[] sorted) {
        int li = ls;
        int ri = rs;
        int si = 0;

        while(li <= le && ri <= re) {
            if (arr[li] <= arr[ri]) {
                sorted[si++] = arr[li++];
            } else {
                sorted[si++] = arr[ri++];
            }
        }

        if (li <= le) {
            while(li <= le) {
                sorted[si++] = arr[li++];
            }
        } else {
            while(ri <= re) {
                sorted[si++] = arr[ri++];
            }
        }

        for (int i = 0; i < si; i++) {
            arr[i + ls] = sorted[i];
        }
    }
}

```

## 카운팅 정렬

요소값의 빈도수를 작은 수부터 누적하면 정렬된 순서가 된다.

1, 1, 3, 5, 9, 11 에서 1은 0, 1번째, 3은 2번째(1이 두 번 나왔으므로), 5는 2+1 번째 (1이 두 번, 3이 1번 나왔으므로)와 같이 빈도수의 누적합은 정렬된 순서를 의미한다.

시간 복잡도는 n인 가장 성능이 좋은 알고리즘이지만, 요소값의 범위가 크면 카운팅 배열이 비효율적으로 커진다는 치명적인 단점이 있다.
예를 들어, 숫자 10개를 정렬하는데, 숫자의 범위가 -1억부터 1억이라면 카운팅 배열은 2억 길이를 가져야 한다.

그래서 정렬할 수의 범위가 적을 때 쓰는 게 유리하다.

### 코드

```java
package algorithm.java.sort;

import java.util.Arrays;
import java.util.List;
import java.util.OptionalInt;

public class CountingSort {
    private int[] arr;

    public CountingSort(int[] arr) {
        this.arr = Arrays.copyOf(arr, arr.length);
    }

    public int[] getArr() {
        return arr;
    }

    protected int min(int arr[]) {
        return Arrays.stream(arr).min().getAsInt();
    }

    protected int max(int arr[]) {
        return Arrays.stream(arr).max().getAsInt();
    }

//    0~111 수만 허용
    public void sort() {
        if (max(arr) > 1000000 || min(arr) < 0) {
            System.out.println("정렬 불가. 허용되는 수 범위는 0~111");
            return;
        }
        countingSort(arr);
    }

    protected void countingSort(int[] arr) {
        int length = arr.length;
        int count[] = new int[1000001];
        int sorted[] = new int[length];
        int maxValue = max(arr);
        for (int i = 0; i < length; i++) {
            count[arr[i]] += 1;
        }

        for (int i = 1; i <= maxValue; i++) {
            count[i] += count[i-1];
        }

        for (int i = length-1; i >= 0; i--) {
            sorted[--count[arr[i]]] = arr[i];
        }

        for (int i = 0; i < length; i++) {
            arr[i] = sorted[i];
        }
    }
}
```

요소값이 중복되지 않는다면 누적합을 구할 필요도 없다.

그냥 카운팅 배열을 순회하면서 값이 있는 경우에 정렬될 배열에 복사하면 된다.

[BOJ2751](https://www.acmicpc.net/problem/2751) 문제 풀이 코드를 참고하자.

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.valueOf(bf.readLine());
        int buffer = 1000000;
        int arr[] = new int[N];
        int count[] = new int[(buffer << 1) + 1];
        
        for(int i = 0; i < N; i++) {
           // 음수값 처리. 출력할 때 원본으로 돌리기 위해 buffer만큼 빼준다.
            arr[i] = Integer.valueOf(bf.readLine()) + buffer;
            count[arr[i]] += 1;
        }

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < count.length; i++) {
            if (count[i] == 1) {
                sb.append(i-buffer).append("\n");
            }
        }
        System.out.println(sb.toString());
    }
}
```

## 라이브러리가 제공하는 정렬

컬렉션, Arrays도 정렬을 제공한다.

```java
Collections.sort(list);
Arrays.sort(arr);
```

## lower_bound / upper_bound

이분 탐색을 이용하여 어떤 리스트(배열)에서 특정 값을 찾을 때, 중복되는 값을 가지고 있을 수 있다. 그 중복값이 몇 개가 있는지 찾는 문제를 해결하기 위해 upper_bound 와 lower_bound가 존재한다.

![image](https://github.com/user-attachments/assets/49b6e172-e02b-4bd6-b68d-35834d9331c2)

[참고](https://velog.io/@layl__a/%EC%9D%B4%EB%B6%84%ED%83%90%EC%83%89-upperbound%EC%99%80-lowerbound-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0)

자바 표준 라이브러리에서 제공하는 것은 없고 직접 구현해야 한다.

```java
private static int lowerBound(long arr[], long key) {
    int l = 0, r = arr.length;

    while (l < r) {
        int mid = (l + r) / 2;
        if (arr[mid] >= key) {
            r = mid;
        } else {
            l = mid + 1;
        }
    }

    return r;
}

private static int upperBound(long arr[], long key) {
    int l = 0, r = arr.length;

    while (l < r) {
        int mid = (l + r) / 2;
        if (arr[mid] <= key) {
            l = mid + 1;
        } else {
            r = mid;
        }
    }

    return l;
}
```

- r은 arr.length로 해야 함을 주의 (최댓값이 키인 경우 반복문 조건인 `l < r`을 만족하려면 r이 arr.length여야 함)
- =을 어디에 둘 것인지가 포인트. lower_bound는 같아도 왼쪽으로 가야 하고, upper_bound는 같아도 오른쪽으로 가야 한다.


## 스택 / 큐 / 덱

```java
package algorithm.java.ds;

import java.util.LinkedList;
import java.util.Stack;
import java.util.StringTokenizer;

public class Example {
    private StringBuilder sb = new StringBuilder();
    private StringTokenizer stringTokenizer = new StringTokenizer("");
    private String cmd;
    public void stack() {
        Stack<Integer> stack = new Stack<>();
        if (cmd.equals("push")) {
            int v = Integer.parseInt(stringTokenizer.nextToken());
            stack.push(v);
        } else if (cmd.equals("pop")) {
            if (stack.empty()) {
                sb.append(-1).append("\n");
            } else {
                Integer v = stack.pop();
                sb.append(v).append("\n");
            }
        } else if (cmd.equals("size")) {
            sb.append(stack.size()).append("\n");
        } else if (cmd.equals("empty")) {
            int v = stack.empty() ? 1 : 0;
            sb.append(v).append("\n");
        } else if (cmd.equals("top")) {
            if (stack.empty()) {
                sb.append(-1).append("\n");
            } else {
                sb.append(stack.peek()).append("\n");
            }
        }
    }

    public void queue() {
        LinkedList<Integer> q = new LinkedList<>();
        if (cmd.equals("push")) {
            int v = Integer.parseInt(stringTokenizer.nextToken());
            q.add(v);
        } else if (cmd.equals("pop")) {
            if (q.isEmpty()) {
                sb.append(-1).append("\n");
            } else {
                Integer v = q.poll();
                sb.append(v).append("\n");
            }
        } else if (cmd.equals("size")) {
            sb.append(q.size()).append("\n");
        } else if (cmd.equals("empty")) {
            int v = q.isEmpty() ? 1 : 0;
            sb.append(v).append("\n");
        } else if (cmd.equals("front")) {
            if (q.isEmpty()) {
                sb.append(-1).append("\n");
            } else {
                sb.append(q.peek()).append("\n");
            }
        } else if (cmd.equals("back")) {
            if (q.isEmpty()) {
                sb.append(-1).append("\n");
            } else {
                Integer v = q.peekLast();
                sb.append(v).append("\n");
            }
        }
    }

    public void deque() {
        LinkedList<Integer> q = new LinkedList<>();
        String cmd = stringTokenizer.nextToken();
        if (cmd.equals("push_front")) {
            int v = Integer.parseInt(stringTokenizer.nextToken());
            q.addFirst(v);
        } else if (cmd.equals("push_back")) {
            int v = Integer.parseInt(stringTokenizer.nextToken());
            q.add(v);
        } else if (cmd.equals("pop_front")) {
            if (q.isEmpty()) {
                sb.append(-1).append("\n");
            } else {
                Integer v = q.poll();
                sb.append(v).append("\n");
            }
        } else if (cmd.equals("pop_back")) {
            if (q.isEmpty()) {
                sb.append(-1).append("\n");
            } else {
                Integer v = q.pollLast();
                sb.append(v).append("\n");
            }
        } else if (cmd.equals("size")) {
            sb.append(q.size()).append("\n");
        } else if (cmd.equals("empty")) {
            int v = q.isEmpty() ? 1 : 0;
            sb.append(v).append("\n");
        } else if (cmd.equals("front")) {
            if (q.isEmpty()) {
                sb.append(-1).append("\n");
            } else {
                sb.append(q.peek()).append("\n");
            }
        } else if (cmd.equals("back")) {
            if (q.isEmpty()) {
                sb.append(-1).append("\n");
            } else {
                Integer v = q.peekLast();
                sb.append(v).append("\n");
            }
        }
    }
}

```

- stack은 push, pop, empty, peek
- queue는 add, poll, isEmpty, peek
- deque(LinkedList)는 addFirst, addLast(add), pollFirst(poll), pollLast, isEmpty, peekFirst(peek), peekLast

## list iterator

링크드 리스트는 o(1) 검색이 되지 않는다.

문제에 따라 iterator를 통해 검색이 가능할 수도 있다.

iterator는 커서 개념이다. 요소와 요소 사이에 있는 것이다. 그래서 `add`는 iterator가 어딜 가리키든 성공하며, 요소와 요소 사이에 넣는다. 빈 배열인 경우에도 요소를 넣는 데 성공한다.
`remove`는 `next`, `prev`에 의해 리턴된 마지막 요소를 제거한다. `remove`도 커서 개념으로 커서의 왼쪽 요소를 지운다고 보면 된다.

boj1406 솔루션 중 핵심 코드이다.

```java
while (N-- > 0) {
    StringTokenizer stringTokenizer = new StringTokenizer(bf.readLine());
    String cmd = stringTokenizer.nextToken();
    if (cmd.equals("L")) {
	if (iter.hasPrevious()) {
	    iter.previous();
	}
    } else if (cmd.equals("D")){
	if (iter.hasNext()) {
	    iter.next();
	}
    } else if (cmd.equals("B")) {
	if (iter.hasPrevious()) {
	    iter.previous();
	    iter.remove();
	}
    } else if (cmd.equals("P")) {
	char v = stringTokenizer.nextToken().charAt(0);
	iter.add(v);
    }
}
```

## 백트래킹

```java
static void dfs(int step) {
	visit[step] = true;
	//do something
	visit[step] = false;
}
```

visit 배열은 반드시 필요하진 않다. 문제에 따라 필요할 때 쓰면 된다.
오히려 visit 배열에 얽매이다보면 해답에 멀어질 수 있다.

B – 1182 부분집합의 합 https://www.acmicpc.net/problem/1182

D – 9663 N-Queen https://www.acmicpc.net/problem/9663

## 에라토스네테스의 체

소수를 구한다.

소수를 구하는 방법은 가장 작은 소수를 구하고, 그 소수의 배수를 지워나가는 것이다.
지워지지 않은 그 다음 작은 수가 또 소수이며, 그 소수의 배수를 또 지워나간다.
이렇게 반복하다보면 소수만 남는다.

이 때 지워나가는 범위에 대해 고민하는 게 좋다.
소수보다 작은 수에 대해서는 고려할 필요가 없다.
그리고 수의 범위가 클 때에는 곱하기를 사용하면 int 범위를 넘어서게 된다.

그래서 가장 효율적인 방법은 다음과 같이 더하기를 사용하여 배수를 구하는 것이다.

```java
//false가 소수이다.
visit[0] = visit[1] = true;
for(int i = 2; i <= N; i++) {
	if (check[i]) continue;
	for (int j = i + i; j <= N; j+=i) {
		check[j] = true;
	}
}
```

## 유클리드 호제법

최대공약수(gcd)와 최소공배수(lcm)을 구한다.

최대공약수를 구하면 최소공배수는 O(1)만에 구할 수 있다.

최대공약수를 구하는 방법은 외우자.
재귀와 반복문이라는 두 가지 방법이 있는데, 아무래도 수의 범위가 클수록 재귀보다는 반복문이 안전할 것이다.

```java
int gcd(int a, int b) {
	while(b != 0) {
		int tmp = b;
		b = a % b;
		a = tmp;
	}
	return a;
}

int lcm(int a, int b, int gcd) {
	return a * b / gcd;
}
```

## 파라메트릭 서치

최댓값/최솟값 최적화 문제를 결정 문제로 풀어낸다.

각 지방정부에 예산을 최대로 배정하는 문제가 예시다.(https://www.acmicpc.net/problem/2512)
예산을 배정할 수 있는 최솟값과 최댓값 사이를 이분 탐색하면서 정해진 예산이 문제의 조건에 부합하는지 결정하면서 풀어나간다.
조건에 부합하는 경우 예산을 늘리고, 그렇지 않으면 예산을 줄이는 것이다.

이렇게 예산을 최대로 배정하는 문제를 "예산을 정해놓고 이 예산이 조건에 맞는지 결정하는 문제"로 바꾸는 것이 핵심이다.

```java
import java.io.*;
import java.util.*;

public class Main {

    public static boolean check(int[] a, int d, int k) {
        int sum = 0;
        for (int v : a) {
            if (v > k) {
                sum += k;
            } else {
                sum += v;
            }
        }

        return sum <= d;
    }

    public static void main(String[] args) throws IOException {

        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));

        int N = Integer.parseInt(bf.readLine());
        int[] a = new int[N];
        StringTokenizer st = new StringTokenizer(bf.readLine());
        int tmp = 0;
        int maxv = 0;
        for (int i = 0; i < N; i++) {
            a[i] = Integer.parseInt(st.nextToken());
            tmp += a[i];
            if (maxv < a[i]) maxv = a[i];
        }
        int d = Integer.parseInt(bf.readLine());

        if (tmp <= d) {
            System.out.println(maxv);
            return;
        }

        int l = 1, r = d - N;
        while(l < r) {
            int mid = (l + r) / 2;
            if (check(a, d, mid)) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }

        System.out.println(l - 1);
    }
}
```

## 유니온 파인드

서로소 집합을 해결하는 문제이다.

어떤 집합이 어떤 집합에 속해있느냐, 독립된 영역의 갯수 등을 묻는 문제이다.

union 오퍼레이션, find 오퍼레이션으로 이루어져있고, 이들은 각각 최적화가 가능하다.

- union: 서로소 집합을 합친다. 트리 높이가 작은 쪽을 큰 쪽으로 합쳐야 최적화할 수 있다.
- find: 요소가 속한 집합을 구한다. memoization으로 최적화할 수 있다.

```java
    static HashMap<String, Integer> counts;
    static HashMap<String, String> parents;

    static String find(String x) {
        if (Objects.equals(parents.get(x), x)) {
            return x;
        } else {
            String r = find(parents.get(x));
            parents.put(x, r);
            return r;
        }
    }

    static void union(String a, String b) {
        String pa = find(a);
        String pb = find(b);
        if (!Objects.equals(pa, pb)) {
            int cpa = counts.get(pa);
            int cpb = counts.get(pb);
            if (cpa > cpb) {
                parents.put(pb, pa);
                counts.put(pa, cpa + cpb);
            } else {
                parents.put(pa, pb);
                counts.put(pb, cpa+cpb);
            }
        }
    }

```


## 다익스트라

한 노드에서 모든 노드로의 최소 경로를 구하는 알고리즘이다.

간선 비용은 양수여야 한다.

- d[N]: 출발 노드에서 다른 모든 노드로의 최소 경로
- visit[N]: 최적화를 위해 방문한 노드는 다시 방문하지 않는다.

다익스트라 알고리즘 특성상 노드를 한 번 방문하면 그 노드에서 할 수 있는 일은 끝난다.
그래서 다시 방문할 필요가 없다.
최적화를 위해서 visit 배열을 통해 노드를 한 번씩만 방문할 수 있도록 처리한다.

```java
package algorithm.java;

import java.io.*;
import java.util.*;

public class Main {
    static int N, M;

    static class Node {
        int city;
        long cost;

        public Node(int city, long cost) {
            this.city = city;
            this.cost = cost;
        }
    }

    static HashMap<Integer, List<Node>> nodes;

    static long dijkstra(int start, int end) {
        PriorityQueue<Node> pq = new PriorityQueue<Node>((a, b) -> {
            if (a.cost == b.cost) {
                return a.city - b.city;
            } else {
                if (a.cost > b.cost) {
                    return 1;
                }else {
                    return -1;
                }
            }
        });

        long[] d = new long[N+1];
        boolean[] visit = new boolean[N+1];
        for (int i = 0; i < N + 1; i++) {
            d[i] = Long.MAX_VALUE;
        }
        d[start] = 0;

        pq.add(new Node(start, d[start]));
        while(!pq.isEmpty()) {
            Node node = pq.poll();
            if (d[node.city] > node.cost) continue;
            if (!nodes.containsKey(node.city)) continue;
            if (visit[node.city]) continue;
            visit[node.city] = true;

            for (Node next : nodes.get(node.city)) {
                if (!visit[next.city] && d[next.city] > d[node.city] + next.cost) {
                    d[next.city] = d[node.city] + next.cost;
                    pq.add(new Node(next.city, d[next.city]));
                }
            }
        }

        return d[end];
    }

    public static void main(String[] args) throws IOException {
        System.setIn(new FileInputStream("input.txt"));
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));

        N = Integer.parseInt(bf.readLine());
        M = Integer.parseInt(bf.readLine());

        nodes = new HashMap<>();
        for (int i = 0; i < M; i++) {
            StringTokenizer st = new StringTokenizer(bf.readLine());
            int s = Integer.parseInt(st.nextToken());
            int e = Integer.parseInt(st.nextToken());
            int c = Integer.parseInt(st.nextToken());
            if (!nodes.containsKey(s)) {
                nodes.put(s, new ArrayList<>());
            }
            nodes.get(s).add(new Node(e, c));
        }

        StringTokenizer st = new StringTokenizer(bf.readLine());
        int s = Integer.parseInt(st.nextToken());
        int e = Integer.parseInt(st.nextToken());

        System.out.println(dijkstra(s, e));
    }
}

```

## 벨만포드 알고리즘

음수가 있는 간선이 포함된 그래프에서 한 노드에서 다른 노드 간의 최단거리를 구하는 알고리즘이다.

기본적으로 모든 간선을 이용하여 갈 수 있는 노드에 최대한 가보는 건데, 출발 노드에서 시작해서 단계적으로 사용할 간선 갯수를 늘린다.

출발 노드에서 시작하여, 간선 1개를 이용하여 갈 수 있는 노드, 다음으로 간선 2개를 이용하여 갈 수 있는 노드, 다음으로 간선 3개를 이용하여 갈 수 있는 노드, 이런 식으로 계속 진행하여 노드의 갯수 - 1만큼 반복한다.
노드의갯수 - 1의 의미는 의미 있는 간선의 최대 갯수이다. 출발 노드에서 제일 멀리 떨어진 노드까지의 간선의 갯수는 최대로 늘려도 노드의 갯수 - 1이기 때문이다.

주의할 점은 출발 노드에서 간선 갯수만큼 방문할 수 있는 노드에 대해서 먼저 확인해야 한다는 점이다. 그래서 그냥 모든 엣지를 조회하는 게 아니라 이미 방문한 엣지인 경우를 체크해야 한다.

```java
    static List<Node> edges = new ArrayList<>();

    static boolean solve(int start) {
        for (int i = 0; i <= N; i++) {
            d[i] = Long.MAX_VALUE;
        }
        d[start] = 0;

        for (int i = 1; i <= N; i++) {
            for (Node edge : edges) {
//주의할 점은 출발 노드에서 간선 갯수만큼 방문할 수 있는 노드에 대해서 먼저 확인해야 한다는 점이다. 그래서 그냥 모든 엣지를 조회하는 게 아니라 이미 방문한 엣지인 경우를 체크해야 한다.
                if (d[edge.start] != Long.MAX_VALUE && d[edge.end] > d[edge.start] + edge.cost) {
                    d[edge.end] = d[edge.start] + edge.cost;
                    if (i == N) {
                        return false;
                    }
                }
            }
        }

        return true;
    }
```

[직관적으로 이해가 됐던 포스팅](https://10000cow.tistory.com/entry/%EB%B2%A8%EB%A7%8C-%ED%8F%AC%EB%93%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%95%9C-%EC%82%B4%EB%8F%84-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-%EB%B2%A8%EB%A7%8C-%ED%8F%AC%EB%93%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98Bellman-Ford-Algorithm)

## 플로이드 알고리즘

모든 노드에서 출발하는 모든 노드로의 최단 거리를 구하는 알고리즘이다.

시간복잡도가 O(N^3)이기 때문에 노드의 갯수가 적을 때 사용할 수 있다.

아이디어는 어찌됐든 최단 거리로 가는 중간 노드가 있을 것이라는 생각에서 출발한다.

출발 노드에서 도착 노드까지의 최단 거리는 어찌됐든 어떤 중간 노드를 타야 최적이다.
이 중간 노드가 어떤 노드일지 모르기 때문에 모든 노드에 대해서 다 계산해본다.

```java
        long[][] d = new long[N+1][N+1];
        for (int i = 1; i <= N; i++) {
            for (int j = 1; j <= N; j++) {
                d[i][j] = INF;
            }
        }
        for (int i = 1; i <= N; i++) {
            d[i][i] = 0;
        }

        for (int i = 0; i < M; i++) {
            StringTokenizer st = new StringTokenizer(bf.readLine());
            int s = Integer.parseInt(st.nextToken());
            int e = Integer.parseInt(st.nextToken());
            int c = Integer.parseInt(st.nextToken());

            d[s][e] = Math.min(d[s][e], c);
        }

        for (int i = 1; i <= N; i++) {
            for (int j = 1; j <= N; j++) {
                for (int k = 1; k <= N; k++) {
                    d[j][k] = Math.min(d[j][k], d[j][i] + d[i][k]);
                }
            }
        }
```

## LCS (Longest common sequences)

두 수열 간의 가장 긴 공통 시퀀스를 찾는 알고리즘이다.

시퀀스란 부분 수열인데, 연속하여 배치할 필요는 없는 수열이다.
예를 들어, ABCDEFGH에서, ABC도 시퀀스이고, ACE도 시퀀스이다.

길이가 M인 수열 X와 길이가 N인 수열 Y이 있을 때, 브루트포스로 해를 구하면 시간복잡도는 O(2^M * N)이 된다.
X의 모든 시퀀스를 찾으려면 O(2^M) 만큼 걸리고, 각 시퀀스에 대해서 수열 Y를 순회하며 비교하니까 O(N)을 곱한다.

LCS를 사용하면 시간복잡도는 O(N*M)이 된다.

LCS의 핵심은 수열을 프리픽스와 끝자리 문자로 나누어 생각하는 것이다.

```
[프리픽스]/[끝자리문자]
e.g) ABC/D
```

두 수열의 프리픽스에 대한 LCS를 구했다고 가정하자. 각 끝자리문자가 같으면 끝자리문자도 LCS에 포함된다. 다르면 "수열X의 프리픽스와 수열Y의 LCS"와 "수열X와 수열Y의 프리픽스의 LCS" 간의 최댓값이 LCS가 된다.
X=ABCD, Y=CBCC라고 할 때, `{ABC, CBCC}`와 `{ABCD, CBC}` 간의 최댓값을 구한다.
`{ABC, CBCC}`는 2(BC), `{ABCD, CBC}`는 2(BC)라서 최댓값은 2가 된다.

그럼 `{ABC, CBCC}`는 어떻게 구할까? 이 값은 이전에 이미 구해진 것이다.
구하려는 LCS는 이전의 LCS를 통해 계산된다.
가장 간단한 프리픽스는 길이가 0인 프리픽스이다.
즉, 프리픽스가 없고 끝자리문자만 있는 상황이다. (X에서는 A, B, C, D, Y에서는 C, B, C, C이다.)
가장 간단한 프리픽스부터 시작하여 모든 프리픽스에 대한 경우의 수를 구한다.
이는 테이블을 통해 직관적으로 파악할 수 있다.

![image](https://github.com/user-attachments/assets/f88d4f7b-569e-4ed0-bd69-deccbed3527a)


코드는 dp를 사용한다.
테이블로 작성한 내용을 dp로 옮기기만 하면 된다.

```java
        String X = "cab";
        String Y = "abb";

        int m = X.length();
        int n = Y.length();

        int[][] c = new int[m+1][n+1];

        //i = 0일 때 빈 수열이고 i = 1일 때 X[0]과 동일하므로 charAt에서 인덱스를 1 빼줘야 한다.
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (X.charAt(i-1) == Y.charAt(j-1)) c[i][j] = c[i-1][j-1] + 1;
                else c[i][j] = Math.max(c[i-1][j], c[i][j-1]);
            }
        }

        System.out.println(c[m][n]);
```

### LCS에 해당하는 문자열 찾기

LCS를 구할 때 사용한 테이블을 가지고 LCS에 해당하는 문자열을 찾는다.

LCS 값에 해당하는 배열의 요소에서 시작하여 역순으로 문자열을 찾는다.
테이블을 보면 알겟지만, LCS를 구하는 경우는 두 가지이다. c[i-1][j-1] + 1과 max(c[i-1][j], c[i][j-1])이다.
여기서 우리는 c[i-1][j-1] + 1로 계산되어 만들어진 위치를 계속 찾아서 역추적해야 한다.
c[i-1][j-1]+1로 계산됐다는 뜻은 해당 위치의 끝자리문자가 LCS에 포함되었다는 의미이기 때문이다.
이 위치를 찾으려면 `c[i][j] != c[i-1][j] && c[i][j] != c[i][j-1]`을 만족해야 한다.

`c[i-1][j-1] + 1 == c[i][j]`로는 완벽히 추적할 수 없음을 주의하자. 
반례) X=ABB, Y=CAB
표
```
  0 C A B
0 0 0 0 0
A 0 0 1 1
B 0 0 1 2
B 0 0 1 2
```

상황에서는 c[2][2] + 1 == c[3][3]를 만족하지만 (2, 2)를 포함해선 안 된다.

```java
        int i = m;
        int j = n;
        StringBuilder sb = new StringBuilder();
        while (i != 0 && j != 0) {
            //1번
            if (c[i][j] != c[i-1][j] && c[i][j] != c[i][j-1]) {
                sb.insert(0, X.charAt(i-1)); //1 빼줘야 한다. 맨 앞에 삽입하여 역순 출력 대체
                i--;
                j--;
            }
            //2번
            else if (c[i][j] != c[i][j-1]) i--;
            else j--;
        }

        System.out.println(sb.toString());
```

## 크루스칼 알고리즘

최소 스패닝 트리를 구성하는 알고리즘.

간선을 정렬하고, 정렬된 간선 리스트를 순회하면서 간선으로 노드를 이을지 말지를 결정한다.
노드를 이을지 말지는 트리로 유지되느냐를 따진다. 즉, 사이클이 생성되는지를 확인한다.
사이클을 확인하는 방법은 유니온 파인드 알고리즘을 사용한다.

이렇게 전체 간선을 돌고 나면 최소 스패닝 트리가 구성된다.

시간복잡도는 O(ElogV). (ElogE 는 O(ElogV)와 같음)

```java
       ArrayList<Edge> edges = new ArrayList<>();
        edges.sort(Comparator.comparingInt(e -> e.c));

        int w = 0;
        for (Edge edge : edges) {
            if (find(edge.s) != find(edge.e)) {
                union(edge.s, edge.e);
                w += edge.c;
            }
        }

        System.out.println(w);
```

## 프림 알고리즘

최소 스패닝 트리를 구성하는 알고리즘.

노드에 연결된 간선 중 최소비용 간선을 선택하여 이어진 노드로 이동한다.
이 때 노드를 이미 방문했다면 다음 최소비용 간선을 선택한다.
이런 식으로 모든 노드를 방문하면(간선을 선택하면) 최소 스패닝 트리가 구성된다.

시간복잡도는 O(ElogV).

```java
       PriorityQueue<Edge> q = new PriorityQueue<>(Comparator.comparingInt(e -> e.c));
        List<List<Edge>> nodes = new ArrayList<>();
        boolean[] visit = new boolean[V + 1];

        for (int i = 0; i <= V; i++) {
            nodes.add(new ArrayList<>());
        }

        for (int i = 0; i < E; i++) {
            st = new StringTokenizer(bf.readLine());
            int s = Integer.parseInt(st.nextToken());
            int e = Integer.parseInt(st.nextToken());
            int c = Integer.parseInt(st.nextToken());

            nodes.get(s).add(new Edge(s, e, c));
            nodes.get(e).add(new Edge(e, s, c));
        }

        for (Edge edge : nodes.get(1)) {
            q.add(edge);
        }
        visit[1] = true;

        int w = 0;
        while(!q.isEmpty()) {
            Edge poll = q.poll();
            if (visit[poll.e]) continue;
            visit[poll.e] = true;
            w+=poll.c;

            for (Edge edge : nodes.get(poll.e)) {
                if (visit[edge.e]) continue;
                q.add(edge);
            }
        }
        System.out.println(w);
```

## 위상정렬

여러 일들 사이에 실행 순서를 정하는 알고리즘.
각 일은 수행되어야 할 이전 일들이 있을 수 있다. 이러한 일 간의 순서를 계산하는 알고리즘이다.

일 간의 순서를 그래프로 표현한다.
A를 해야 B를 실행할 수 있다면, A는 B로의 단방향 간선이 존재하게 된다.

위상정렬은 "디펜던시가 없는 일이 순서상 가장 먼저"라는 아이디어에서 출발한다.
디펜던시가 없는 일을 A라고 하자.
A를 찾았으면, 그 노드와 연결된 다른 노드들(B, C)을 찾는다.

찾은 각 노드에 대하여 A와의 연결을 끊었을 때 디펜던시가 없는 노드가 되는지 확인한다.
디펜던시가 없다면 다음 순서가 된다.

이런 식으로 모든 노드를 순회한다.

사이클이 있는 경우라면 모든 노드를 순회할 수 없다.

시간복잡도는 O(V+E)이다.

```java
        List<List<Integer>> nodes = new ArrayList<>();
        int[] d = new int[N+1];
        for (int i = 0; i <= N; i++) {
            nodes.add(new ArrayList<>());
        }

        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(bf.readLine());
            int s = Integer.parseInt(st.nextToken());
            int e = Integer.parseInt(st.nextToken());

            nodes.get(s).add(e);
            d[e] += 1;
        }

        LinkedList<Integer> q = new LinkedList<>();
        for (int i = 1; i <= N; i++) {
            if (d[i] == 0) {
                q.add(i);
            }
        }

        ArrayList<Integer> sorted = new ArrayList<>();
        while (!q.isEmpty()) {
            Integer poll = q.poll();
            sorted.add(poll);

            for (Integer o : nodes.get(poll)) {
                d[o] -= 1;
                if (d[o] == 0) {
                    q.add(o);
                }
            }
        }

        StringBuilder sb = new StringBuilder();
        for (Integer i : sorted) {
            sb.append(i).append(" ");
        }
        System.out.println(sb.toString());
```

## 세그먼트트리

이진으로 쪼개 놓은 구간합을 이용하여 구간합을 구하는 알고리즘이다.

각 노드는 특정 구간합을 의미한다.

루트노드부터 접근하여 노드가 쿼리의 구간에 포함되는지를 확인하며 구간합을 계산해나간다.
노드가 구간에 포함되면 노드가 갖고 있는 구간합을 포함해야 하고, 노드가 구간에 포함되지 않으면(아예 포함되지 않거나, 부분적으로 포함되어 있거나, 노드가 쿼리 구간을 포함하는 경우 모두 "포함하지 않는다"라고 본다) 자식 노드로 이행한다. (자식 노드로 이행한다는 것은 결국 노드의 구간을 쪼갠다는 뜻이다)

```java
static class SegmentTree {
        long[] tree;
        int n;

        public SegmentTree(long[] arr) {
            this.n = arr.length - 1;
            init(arr);
        }

        void init(long[] arr) {
            int h = (int)Math.ceil(Math.log(n) / Math.log(2));
            int ts = (int)Math.pow(2, h+1);
            tree = new long[ts];
            makeTree(1, n, 1, arr);
        }

        long makeTree(int l, int r, int node, long[] arr) {
            if (l == r) {
                return tree[node] = arr[l];
            }
            int mid = (l + r) / 2;
            return tree[node] = makeTree(l, mid,node * 2, arr) + makeTree(mid+1, r, node * 2 + 1, arr);
        }

        long sum(int l, int r, int node, int s, int e) {
            if (r < s || l > e) return 0;
            if (s <= l && r <= e) {
                return tree[node];
            }
            int mid = (l + r) / 2;
            return sum(l, mid, node*2, s, e) + sum(mid + 1, r, node*2 + 1, s, e);
        }

        void update(int l, int r, int node, int idx, long diff) {
            if (l <= idx && idx <= r) {
                tree[node] += diff;
                if (l == r) {
                    return;
                }
                int mid = (l + r) / 2;
                update(l, mid, node*2, idx, diff);
                update(mid+1, r, node*2+1, idx, diff);
            }
        }
    }

```

https://loosie.tistory.com/273

## 팬윅트리

이진으로 쪼개 놓은 구간합을 이용하여 기본적으로는 부분합을 구하는 알고리즘이다.
부분합을 구해놓으면 구간합도 구할 수 있다.

세그먼트트리가 이진으로 쪼갤 수 있는 모든 구간합을 구해놓는다면 팬윅트리는 구간합을 구하는 데 있어서 불필요하게 쪼개놓은 구간합을 제거한다.
`[8-15]` 구간합은 `[0-15]` - `[0-8]`로 구할 수 있기 때문에 제외하는 식이다.

> 같은 원리로, 하나의 긴 구간 밑에 두 개의 작은 구간이 있을 때 이 두 구간 중 오른쪽 구간은 항상 지워도 된다.

![image](https://github.com/user-attachments/assets/6057bbdd-a190-4084-a155-e70bcaf4a554)
출처: https://loosie.tistory.com/647

### 이진수로 표현하여 배열 정의하기

남은 구간의 갯수는 N이다. 트리는 딱 수열의 갯수만큼의 노드가 필요하다는 뜻이다.

트리는 n=2^x 꼴에서 필요한 n만큼만 채우는 식으로 만든다.

예를 들어, n=5일 때 n보다 큰 가장 작은 2^x 꼴은 2^3이므로, 2^3으로 만들어지는 이진트리에서 5개의 노드만 구성한다.

```
2^3의 트리.
[         8]
[    4]
[  2]     [  6]
[1] [3]  [5]    [7]

n=5일 때 트리
[    4]
[  2]     
[1] [3]  [5]    
```

tree[i]는 A[i]에서 앞으로 L[i]개의 합이다.
L[i]는 i의 이진수표현에서 마지막 1의 값이다.
L[1] = 1, L[4] = 4, L[12] = 4, L[8] = 8 이다.

예를 들어, tree[12] = A[12] + A[11] + A[10] + A[9] 이다. (L[12]개)

![image](https://github.com/user-attachments/assets/4dbd91c8-9181-4588-9d13-5abe445a1440)
출처: https://www.acmicpc.net/blog/view/21

여기서 L[i]는 (i & -i)로 구할 수 있다.

어떤 수 i에 대하여 이진수 표현에서 가장 마지막 1의 위치가 x라고 하자.
x+1 위치부터는 모두 0이기 때문에 반전을 해서 1을 더해주면 x 위치의 값에 +1이 전파된다.
이 때 x 위치의 값은 반전했으므로 0이고, +1을 더해주면 다시 1이 된다.
그리고 x의 위치가 아닌 다른 모든 값은 원래 i와 반전된 값을 갖게 된다.
이를 i와 앤드연산을 하게 되면 x 위치의 값만 남는다.

### 팬윅트리의 두 가지 연산 구현하기

팬윅트리의 두 가지 연산은 배열값 변경과 부분합 구하기이다.

배열값 변경은 인덱스가 포함된 범위를 모두 찾아서 업데이트한다.
찾는 방법은 이진수표현에서 마지막 1값을 찾고, 그 값을 인덱스에 더해주는 것이다.

```java
void update(int pos, int diff) {
	while(pos < n) {
		tree[pos] += diff;
		pos += (pos & -pos);
	}
}
```

배열값을 트리에서의 노드라고 생각하면 노드의 위치의 경우의 수는 두 가지이다.
부모 기준으로 왼쪽에 있을 수도 있고, 조부모 기준으로 오른쪽 자식(부모)의 왼쪽에 있을 수 있다.
첫 번째 경우에는 마지막 1값을 더해주면 부모로 이동하게 된다.
두 번째 경우에는 마지막 1값을 더해주면 조부모로 이동하게 된다.
그래서 인덱스에 마지막 1값을 더해준다.

부분합 구하기는 인덱스가 포함되지 않는 이전 범위를 찾아 해당 구간합을 모두 더해준다.
찾는 방법은 이진수표현에서 마지막 1값을 찾는 것이다.
마지막 1값을 찾았다면 그 위치를 0으로 만들고 다음 마지막 1값을 찾는다.


```java
long sum(int node) {
	long ret = 0;
	while(node > 0) {
		ret += tree[node];
		node &= (node - 1);
	}
}
```

인덱스의 이진수표현에서 1로 set된 위치의 값은 이전 구간의 범위이다.
예를 들어, 인덱스가 12라면 12 = 1100(2)인데, 12는 트리에서 1000(2)에 의해 오른쪽으로 갈라지게 된다.
트리 상에서 1000(2)보다 작은 인덱스는 1000(2)의 자식으로 들어가고, 그보다 큰 인덱스는 1000(2)의 자식이 되지 못하고 오른쪽에 위치하게 된다.
이는 이전 구간의 범위를 찾을 때 1000(2)를 찾아야 한다는 뜻이다. 그러면 1000(2) 밑의 자식 노드를 방문하지 않고도 구간합을 구할 수 있기 때문이다.
결국 트리 상에서 인덱스가 이동하는 경로는 높이가 1씩 낮아진 어느 노드인데, 그 노드는 바로 이전에 자신을 배치시켰던 상위 노드이다.
그래서 인덱스의 마지막 1값을 찾고 이를 unset하는 것이다.

![image](https://github.com/user-attachments/assets/8b45073c-a473-416e-b952-2c2dc7b80b0f)

출처: https://loosie.tistory.com/647



```java
    static class FenwickTree {
        int n;
        long[] tree;

        public FenwickTree(long[] arr) {
            makeTree(arr);
        }

        private void makeTree(long[] arr) {
            this.n = arr.length;
            tree = new long[n];
            for (int i = 1; i < this.n; i++) {
                update(i, arr[i]);
            }
        }

        public long sum(int s, int e) {
            return _sum(e) - _sum(s - 1);
        }

        private long _sum(int node) {
            int n = node;
            long ret = 0;
            while(n > 0) {
                ret += tree[n];
                n &= (n - 1);
            }
            return ret;
        }

        public void update(int idx, long diff) {
            int n = idx;
            while(n < this.n) {
                tree[n] += diff;
                n += (n & -n);
            }
        }
    }
```

## CCW

한 선분을 중심으로 다른 점이 시계방향쪽에 있는지, 반시계방향쪽에 있는지 확인하는 알고리즘이다.

두 개의 벡터의 외적은 법선벡터이며, 법선벡터의 방향이 양이면 반시계방향, 음이면 시계방향이다.

```
(x2-x1, y2-y1), (x3-x2, y3-y2) 두 개의 벡터를 외적하면,
이차원의 외적은 ad-bc이므로,
(x2-x1)*(y3-y2) - (x3-x2)*(y2-y1)이다.

이를 전개하면,
x1y2 - x2y1 + x2y3 - x3y2 + x3y1 - x1y3
가 된다.

신발끈 공식과 같은 결과이다.
x1 x2 x3 x1
  x  x  x
y1 y2 y3 y1
```


## 면적 구하기

두 벡터의 외적의 크기는 두 벡터가 이루는 평행사변형의 넓이와 같다.

```
X = a와 b 사이의 각
axb = |a||b|sinX
```

이를 이용하여 다각형을 여러 개의 삼각형으로 쪼개어 면적을 구할 수 있다.

## 직선의 교점 구하기

벡터는 곧 점이다.
두 점이 주어지면 하나의 직선방정식을 구할 수 있듯이, 두 벡터는 하나의 직선을 표현할 수 있다.

```
r, r0, v는 벡터
t는 스칼라
r = r0 + tv

v는 방향벡터. (꼭 단위벡터일 필요는 없음)
```

두 개의 직선이 있을 때 이들이 교점을 이루는지, 이룬다면 그 값이 무엇인지를 벡터를 통해서 더 쉽게 알아낼 수 있다.

```
a+pb, c+qd 라는 두 직선이 교점이 있는 경우,
p = |(c-a)xd| / |cxd|
이다. (교점이 있으니 그 교점은 두 직선을 지나야 하므로, ax+pbx = cx+qdx, ay+pby = cy+qdy에서 p를 구하면 위와 같이 정리됨)

교점은 (ax+pbx, ay+pby)가 된다.
```

## 그레이엄 스캔(Graham's scan)

Convex Hull 문제를 해결하는 알고리즘 중 하나이다.

기준점에서 각도가 가장 낮은 점부터 CCW를 확인하고, 시계방향으로 꺾인다면 볼록다각형의 꼭짓점으로 선택한다.
CCW를 확인하려면 최소 세 개의 점이 필요하다. 가장 최근에 확인한 두 점을 가져오고, 현재 확인하려 하는 한 개의 점에 대해 CCW를 구한다.
만약 반시계방향이라면 중간점(가장 최근에 확인한 두 점 중 최근 점)을 제거하고, 그 다음 최근에 확인한 점을 가져와 다시 확인한다.
모든 점에 대해서 확인하면 볼록다각형이 만들어진다.

```java
        int N = Integer.parseInt(bf.readLine());
        long[][] p = new long[N][2];
        for (int i = 0; i < N; i++) {
            StringTokenizer st = new StringTokenizer(bf.readLine());
            long x = Long.parseLong(st.nextToken());
            long y = Long.parseLong(st.nextToken());
            p[i][0] = x;
            p[i][1] = y;
        }

        Arrays.sort(p, (a, b) -> {
            if (a[1] == b[1]) {
                if (a[0] > b[0]) {
                    return 1;
                } else {
                    return -1;
                }
            } else if (a[1] > b[1]) {
                return 1;
            } else {
                return -1;
            }
        });

        long[] s = {p[0][0], p[0][1]};
        Arrays.sort(p, (a, b) -> {
            long ccw = ccw(s, a, b);
            if (ccw > 0) {
                return -1;
            } else if (ccw < 0) {
                return 1;
            } else {
                long da = distance(s, a);
                long db = distance(s, b);
                if (da < db) {
                    return -1;
                } else if (da > db){
                    return 1;
                } else {
                    return 0;
                }
            }
        });

        Stack<Integer> st = new Stack<>();

        st.add(0);
        st.add(1);
        for (int i = 2; i < N; i++) {
            while(st.size() > 1) {
                int second = st.pop();
                int first = st.peek();

                if(ccw(p[first], p[second], p[i]) > 0) {
                    st.add(second);
                    break;
                }
            }

            st.add(i);
        }
```

