## BOJ 제출 샘플

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Main {

	public static void main(String[] args) throws IOException {
	   System.out.println("Hello World!"); 
	}
}
```

- 패키지 명시 없음에 주의
- 클래스는 Main으로 고정

## 입력과 출력

```java
import java.io.*;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Main {

    public static void main(String[] args) throws IOException {
//        System.setIn(new FileInputStream("input.txt"));
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(bf.readLine());
        long[] arr = new long[N];

        StringTokenizer stringTokenizer = new StringTokenizer(bf.readLine());
        for (int i = 0; i < N; i++) {
            long d = Long.parseLong(stringTokenizer.nextToken());
            arr[i] = d;
        }

        Arrays.sort(arr);

        int M = Integer.parseInt(bf.readLine());
        stringTokenizer = new StringTokenizer(bf.readLine());

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < M; i++) {
            long key = Long.parseLong(stringTokenizer.nextToken());
            long found = Arrays.binarySearch(arr, key);
            if (found >= 0) {
                sb.append(1).append("\n");
            } else {
                sb.append(0).append("\n");
            }
        }

        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        bw.write(sb.toString());
        bw.close();
    }
}      
```

- `BufferedReader`로 인풋 처리 속도 증가
- `BufferedWriter`로 아웃풋 처리 속도 증가
- `StringTokenizer`로 공백 구분 인풋 처리
- `StringBuilder`로 문자열 합성 처리
- `System.setIn`으로 파일에서 인풋을 받음
- string -> int는 `Integer.parseInt()`

`input.txt`는 프로젝트 루트에 존재
![image](https://github.com/user-attachments/assets/6b0a3250-4db7-4150-a8e4-61e032e6c1ad)


## 배열

```java
//정렬
long[] arr = new long[N];
Arrays.sort(arr);

//바이너리 서치
long found = Arrays.binarySearch(arr, key);
if (found >= 0) {
    sb.append(1).append("\n");
} else {
    sb.append(0).append("\n");
}
```

## 이진 탐색

정렬된 리스트에서 탐색 범위를 반으로 줄여가며 탐색.

정렬된 리스트이기 때문에 반으로 줄여가며 탐색할 수 있고, 반으로 탐색할 수 있기 때문에 탐색 시간이 log 단위로 떨어짐.

```java
//재귀
int biSearch2(int arr[], int left, int right, int key) {
  if (left > right) return -1;

  int mid = (left + right) / 2;
  if (arr[mid] < key) {
    left = mid + 1;
  } else if (arr[mid] > key) {
    right = mid;
  } else {
    return mid;
  }
  return biSearch2(arr, left, right, key);
}

//반복문
int biSearch(int arr[], int left, int  right, int key) {

  while(left<=right) {
    int mid = (left + right) / 2;

    if (arr[mid] < key) {
      left = mid + 1;
    } else if (arr[mid] > key) {
      right = mid;
    } else {
      return mid;
    }
  }

  return -1;
}
```

라이브러리에서도 지원하고 있다.

```java
int key = 1;
int found = Arrays.sort(arr, key);
if (found < 0) {
	//못찾음.
} else {
	// 찾음. 인덱스 리턴. 동일값이 여러 개일 때는 먼저 찾은 인덱스 리턴.
}
```

## 퀵 정렬

피봇을 기준으로 오른쪽에 큰 값, 왼쪽에 작은 값을 "최대한" 배치하려는 정렬.

"최대한"이라서 한 번에 되지는 않는다.

전체 구간에 대해 피봇을 정해서 한 번의 정렬을 끝내고, 피봇의 왼쪽 구간, 오른쪽 구간에 대해서도 각각 재귀적으로 피봇을 잡아 정렬한다.

이렇게 재귀적으로 가게 되면 구간이 작아지는데, 구간이 1일 때는 비로소 정렬의 완벽성을 보장할 수 있다.

구간이 1일 때까지 정렬을 마치 그 순간 전체 구간에 대한 정렬이 완성된다.

### 시간 복잡도

nlogn 인데, 피봇을 어떻게 잡느냐에 따라 다르다.

결국 퀵소트가 로그 시간으로 떨어지는 이유는 피봇이 중간값이기 때문이다.

피봇을 기준으로 오른쪽에 큰 값, 왼쪽에 작은 값을 배치하면, 결국 피봇은 정렬된 리스트에서의 자기 자리와 근접한 위치로 가게 된다.

이 때, 피봇이 중간값이면 정렬된 리스트에서의 자기 자리를 기준으로 왼쪽과 오른쪽으로 다음 구간을 나누기 때문에, 각 구간은 거의 절반의 크기로 쪼개진다.

그런데 피봇이 양극단의 값(최댓값 혹은 최솟값)이면 정렬된 리스트에서의 자기 자리가 양극단이기 때문에, 한 쪽 구간이 크고 다른 한 쪽 구간은 작게 쪼개진다.

그래서 로그 시간으로 떨어지지 않고, n^2에 근접한다.

방법은 피봇을 랜덤하게 잡는 것이다.

![image](https://github.com/user-attachments/assets/2ce9736f-d1ae-4ac1-9c45-db7732d3b94b)

피봇을 어떻게 잡느냐에 따라 [BOJ2751](https://www.acmicpc.net/problem/2751) 문제처럼 통과되기도 하고 아니기도 한다.

### 코드

```java
package algorithm.java.sort;

import java.util.Arrays;

public class QuickSort {
    private int arr[];

    public QuickSort(int[] arr) {
        this.arr = Arrays.copyOf(arr, arr.length);
    }

    public int[] getArr() {
        return arr;
    }

    public void sort() {
        _sort(0, arr.length - 1, arr);
    }

    private int pivot(int start, int end) {
        return (int) (Math.random() * (end - start + 1) + start);
    }

    private void _sort(int start, int end, int[] arr) {
        if (start >= end) {
            return;
        }

        int pivot = arr[pivot(start, end)];
        int left = start;
        int right = end;

        while(left <= right) {
            while(arr[left] < pivot) left++;
            while(arr[right] > pivot) right--;

            if(left <= right) {
                int tmp = arr[left];
                arr[left] = arr[right];
                arr[right] = tmp;

                left += 1;
                right -= 1;
            }
        }

        if (start < right) {
            _sort(start, right, arr);
        }
        if (left < end) {
            _sort(left, end, arr);
        }
    }
}
```

## 머지 소트

원본 배열을 부분 리스트로 쪼개고, 두 개의 부분리스트를 짝을 지어 부분리스트 간 값 비교를 통해 정렬한다.

가장 작은 부분리스트(길이가 1, 즉 요소 1개) 간 정렬을 완료하면 길이가 2인 부분리스트를 구하고 그 부분리스트 간의 정렬을 진행한다.

결과적으로 전체리스트가 정렬된다.

시간복잡도는 nlogn이며, 구현 과정에서 정렬된 리스트를 담을 배열이 하나 필요하기 때문에 공간복잡도 n이 요구된다.

퀵소트는 피봇을 어떻게 잡느냐에 따라 시간복잡도가 달라지지만, 머지소트는 비교적 stable한 성능을 보인다.

### 코드

```java
package algorithm.java.sort;

import java.util.Arrays;

public class MergeSort {
    private int[] arr;

    public MergeSort(int[] arr) {
        this.arr = Arrays.copyOf(arr, arr.length);
    }

    public int[] getArr() {
        return arr;
    }

    public void sort() {
        mergeSort(0, arr.length - 1, arr);
    }

    protected void mergeSort(int start, int end, int[] arr) {
        int length = arr.length;
        int sorted[] = Arrays.copyOf(arr, length);
        //부분리스트의 사이즈를 2배씩 늘려간다. 1 -> 2 -> 4 -> 8...
        for(int size = 1; size < length; size <<= 1) {
            //ls = left sublist start index.
            //le = left sublist end index.
            //rs = right sublist start index.
            //re = right sublist end index.
            //두 개의 부분리스트를 구한다. 구한다는 것은 각 부분리스트의 처음과 끝 index를 구한다는 것이다.
            for(int ls = 0; ls + size <= end; ls+=(size<<1)) {
                int le = ls + size-1;
                int rs = le + 1;
                int re = Math.min(rs + size-1, end);

                merge(ls, le, rs, re, arr, sorted);
            }
        }
    }

    //두 부분 리스트 간 값 비교를 통해 정렬한다.
    protected void merge(int ls, int le, int rs, int re, int[] arr, int[] sorted) {
        int li = ls;
        int ri = rs;
        int si = 0;

        while(li <= le && ri <= re) {
            if (arr[li] <= arr[ri]) {
                sorted[si++] = arr[li++];
            } else {
                sorted[si++] = arr[ri++];
            }
        }

        if (li <= le) {
            while(li <= le) {
                sorted[si++] = arr[li++];
            }
        } else {
            while(ri <= re) {
                sorted[si++] = arr[ri++];
            }
        }

        for (int i = 0; i < si; i++) {
            arr[i + ls] = sorted[i];
        }
    }
}

```

## 카운팅 정렬

요소값의 빈도수를 작은 수부터 누적하면 정렬된 순서가 된다.

1, 1, 3, 5, 9, 11 에서 1은 0, 1번째, 3은 2번째(1이 두 번 나왔으므로), 5는 2+1 번째 (1이 두 번, 3이 1번 나왔으므로)와 같이 빈도수의 누적합은 정렬된 순서를 의미한다.

시간 복잡도는 n인 가장 성능이 좋은 알고리즘이지만, 요소값의 범위가 크면 카운팅 배열이 비효율적으로 커진다는 치명적인 단점이 있다.
예를 들어, 숫자 10개를 정렬하는데, 숫자의 범위가 -1억부터 1억이라면 카운팅 배열은 2억 길이를 가져야 한다.

그래서 정렬할 수의 범위가 적을 때 쓰는 게 유리하다.

### 코드

```java
package algorithm.java.sort;

import java.util.Arrays;
import java.util.List;
import java.util.OptionalInt;

public class CountingSort {
    private int[] arr;

    public CountingSort(int[] arr) {
        this.arr = Arrays.copyOf(arr, arr.length);
    }

    public int[] getArr() {
        return arr;
    }

    protected int min(int arr[]) {
        return Arrays.stream(arr).min().getAsInt();
    }

    protected int max(int arr[]) {
        return Arrays.stream(arr).max().getAsInt();
    }

//    0~111 수만 허용
    public void sort() {
        if (max(arr) > 1000000 || min(arr) < 0) {
            System.out.println("정렬 불가. 허용되는 수 범위는 0~111");
            return;
        }
        countingSort(arr);
    }

    protected void countingSort(int[] arr) {
        int length = arr.length;
        int count[] = new int[1000001];
        int sorted[] = new int[length];
        int maxValue = max(arr);
        for (int i = 0; i < length; i++) {
            count[arr[i]] += 1;
        }

        for (int i = 1; i <= maxValue; i++) {
            count[i] += count[i-1];
        }

        for (int i = length-1; i >= 0; i--) {
            sorted[--count[arr[i]]] = arr[i];
        }

        for (int i = 0; i < length; i++) {
            arr[i] = sorted[i];
        }
    }
}
```

요소값이 중복되지 않는다면 누적합을 구할 필요도 없다.

그냥 카운팅 배열을 순회하면서 값이 있는 경우에 정렬될 배열에 복사하면 된다.

[BOJ2751](https://www.acmicpc.net/problem/2751) 문제 풀이 코드를 참고하자.

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.valueOf(bf.readLine());
        int buffer = 1000000;
        int arr[] = new int[N];
        int count[] = new int[(buffer << 1) + 1];
        
        for(int i = 0; i < N; i++) {
           // 음수값 처리. 출력할 때 원본으로 돌리기 위해 buffer만큼 빼준다.
            arr[i] = Integer.valueOf(bf.readLine()) + buffer;
            count[arr[i]] += 1;
        }

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < count.length; i++) {
            if (count[i] == 1) {
                sb.append(i-buffer).append("\n");
            }
        }
        System.out.println(sb.toString());
    }
}
```

## 라이브러리가 제공하는 정렬

컬렉션, Arrays도 정렬을 제공한다.

```java
Collections.sort(list);
Arrays.sort(arr);
```

## lower_bound / upper_bound

이분 탐색을 이용하여 어떤 리스트(배열)에서 특정 값을 찾을 때, 중복되는 값을 가지고 있을 수 있다. 그 중복값이 몇 개가 있는지 찾는 문제를 해결하기 위해 upper_bound 와 lower_bound가 존재한다.

![image](https://github.com/user-attachments/assets/49b6e172-e02b-4bd6-b68d-35834d9331c2)

[참고](https://velog.io/@layl__a/%EC%9D%B4%EB%B6%84%ED%83%90%EC%83%89-upperbound%EC%99%80-lowerbound-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0)

자바 표준 라이브러리에서 제공하는 것은 없고 직접 구현해야 한다.

```java
private static int lowerBound(long arr[], long key) {
    int l = 0, r = arr.length;

    while (l < r) {
        int mid = (l + r) / 2;
        if (arr[mid] >= key) {
            r = mid;
        } else {
            l = mid + 1;
        }
    }

    return r;
}

private static int upperBound(long arr[], long key) {
    int l = 0, r = arr.length;

    while (l < r) {
        int mid = (l + r) / 2;
        if (arr[mid] <= key) {
            l = mid + 1;
        } else {
            r = mid;
        }
    }

    return l;
}
```

- r은 arr.length로 해야 함을 주의 (최댓값이 키인 경우 반복문 조건인 `l < r`을 만족하려면 r이 arr.length여야 함)
- =을 어디에 둘 것인지가 포인트. lower_bound는 같아도 왼쪽으로 가야 하고, upper_bound는 같아도 오른쪽으로 가야 한다.


## 스택 / 큐 / 덱

```java
package algorithm.java.ds;

import java.util.LinkedList;
import java.util.Stack;
import java.util.StringTokenizer;

public class Example {
    private StringBuilder sb = new StringBuilder();
    private StringTokenizer stringTokenizer = new StringTokenizer("");
    private String cmd;
    public void stack() {
        Stack<Integer> stack = new Stack<>();
        if (cmd.equals("push")) {
            int v = Integer.parseInt(stringTokenizer.nextToken());
            stack.push(v);
        } else if (cmd.equals("pop")) {
            if (stack.empty()) {
                sb.append(-1).append("\n");
            } else {
                Integer v = stack.pop();
                sb.append(v).append("\n");
            }
        } else if (cmd.equals("size")) {
            sb.append(stack.size()).append("\n");
        } else if (cmd.equals("empty")) {
            int v = stack.empty() ? 1 : 0;
            sb.append(v).append("\n");
        } else if (cmd.equals("top")) {
            if (stack.empty()) {
                sb.append(-1).append("\n");
            } else {
                sb.append(stack.peek()).append("\n");
            }
        }
    }

    public void queue() {
        LinkedList<Integer> q = new LinkedList<>();
        if (cmd.equals("push")) {
            int v = Integer.parseInt(stringTokenizer.nextToken());
            q.add(v);
        } else if (cmd.equals("pop")) {
            if (q.isEmpty()) {
                sb.append(-1).append("\n");
            } else {
                Integer v = q.poll();
                sb.append(v).append("\n");
            }
        } else if (cmd.equals("size")) {
            sb.append(q.size()).append("\n");
        } else if (cmd.equals("empty")) {
            int v = q.isEmpty() ? 1 : 0;
            sb.append(v).append("\n");
        } else if (cmd.equals("front")) {
            if (q.isEmpty()) {
                sb.append(-1).append("\n");
            } else {
                sb.append(q.peek()).append("\n");
            }
        } else if (cmd.equals("back")) {
            if (q.isEmpty()) {
                sb.append(-1).append("\n");
            } else {
                Integer v = q.peekLast();
                sb.append(v).append("\n");
            }
        }
    }

    public void deque() {
        LinkedList<Integer> q = new LinkedList<>();
        String cmd = stringTokenizer.nextToken();
        if (cmd.equals("push_front")) {
            int v = Integer.parseInt(stringTokenizer.nextToken());
            q.addFirst(v);
        } else if (cmd.equals("push_back")) {
            int v = Integer.parseInt(stringTokenizer.nextToken());
            q.add(v);
        } else if (cmd.equals("pop_front")) {
            if (q.isEmpty()) {
                sb.append(-1).append("\n");
            } else {
                Integer v = q.poll();
                sb.append(v).append("\n");
            }
        } else if (cmd.equals("pop_back")) {
            if (q.isEmpty()) {
                sb.append(-1).append("\n");
            } else {
                Integer v = q.pollLast();
                sb.append(v).append("\n");
            }
        } else if (cmd.equals("size")) {
            sb.append(q.size()).append("\n");
        } else if (cmd.equals("empty")) {
            int v = q.isEmpty() ? 1 : 0;
            sb.append(v).append("\n");
        } else if (cmd.equals("front")) {
            if (q.isEmpty()) {
                sb.append(-1).append("\n");
            } else {
                sb.append(q.peek()).append("\n");
            }
        } else if (cmd.equals("back")) {
            if (q.isEmpty()) {
                sb.append(-1).append("\n");
            } else {
                Integer v = q.peekLast();
                sb.append(v).append("\n");
            }
        }
    }
}

```

- stack은 push, pop, empty, peek
- queue는 add, poll, isEmpty, peek
- deque(LinkedList)는 addFirst, addLast(add), pollFirst(poll), pollLast, isEmpty, peekFirst(peek), peekLast

## list iterator

링크드 리스트는 o(1) 검색이 되지 않는다.

문제에 따라 iterator를 통해 검색이 가능할 수도 있다.

iterator는 커서 개념이다. 요소와 요소 사이에 있는 것이다. 그래서 `add`는 iterator가 어딜 가리키든 성공하며, 요소와 요소 사이에 넣는다. 빈 배열인 경우에도 요소를 넣는 데 성공한다.
`remove`는 `next`, `prev`에 의해 리턴된 마지막 요소를 제거한다. `remove`도 커서 개념으로 커서의 왼쪽 요소를 지운다고 보면 된다.

boj1406 솔루션 중 핵심 코드이다.

```java
while (N-- > 0) {
    StringTokenizer stringTokenizer = new StringTokenizer(bf.readLine());
    String cmd = stringTokenizer.nextToken();
    if (cmd.equals("L")) {
	if (iter.hasPrevious()) {
	    iter.previous();
	}
    } else if (cmd.equals("D")){
	if (iter.hasNext()) {
	    iter.next();
	}
    } else if (cmd.equals("B")) {
	if (iter.hasPrevious()) {
	    iter.previous();
	    iter.remove();
	}
    } else if (cmd.equals("P")) {
	char v = stringTokenizer.nextToken().charAt(0);
	iter.add(v);
    }
}
```

## 백트래킹

```java
static void dfs(int step) {
	visit[step] = true;
	//do something
	visit[step] = false;
}
```

visit 배열은 반드시 필요하진 않다. 문제에 따라 필요할 때 쓰면 된다.
오히려 visit 배열에 얽매이다보면 해답에 멀어질 수 있다.

B – 1182 부분집합의 합 https://www.acmicpc.net/problem/1182

D – 9663 N-Queen https://www.acmicpc.net/problem/9663

## 에라토스네테스의 체

소수를 구한다.

소수를 구하는 방법은 가장 작은 소수를 구하고, 그 소수의 배수를 지워나가는 것이다.
지워지지 않은 그 다음 작은 수가 또 소수이며, 그 소수의 배수를 또 지워나간다.
이렇게 반복하다보면 소수만 남는다.

이 때 지워나가는 범위에 대해 고민하는 게 좋다.
소수보다 작은 수에 대해서는 고려할 필요가 없다.
그리고 수의 범위가 클 때에는 곱하기를 사용하면 int 범위를 넘어서게 된다.

그래서 가장 효율적인 방법은 다음과 같이 더하기를 사용하여 배수를 구하는 것이다.

```java
//false가 소수이다.
visit[0] = visit[1] = true;
for(int i = 2; i <= N; i++) {
	if (check[i]) continue;
	for (int j = i + i; j <= N; j+=i) {
		check[j] = true;
	}
}
```

## 유클리드 호제법

최대공약수(gcd)와 최소공배수(lcm)을 구한다.

최대공약수를 구하면 최소공배수는 O(1)만에 구할 수 있다.

최대공약수를 구하는 방법은 외우자.
재귀와 반복문이라는 두 가지 방법이 있는데, 아무래도 수의 범위가 클수록 재귀보다는 반복문이 안전할 것이다.

```java
int gcd(int a, int b) {
	while(b != 0) {
		int tmp = b;
		b = a % b;
		a = tmp;
	}
	return a;
}

int lcm(int a, int b, int gcd) {
	return a * b / gcd;
}
```

## 파라메트릭 서치

최댓값/최솟값 최적화 문제를 결정 문제로 풀어낸다.

각 지방정부에 예산을 최대로 배정하는 문제가 예시다.(https://www.acmicpc.net/problem/2512)
예산을 배정할 수 있는 최솟값과 최댓값 사이를 이분 탐색하면서 정해진 예산이 문제의 조건에 부합하는지 결정하면서 풀어나간다.
조건에 부합하는 경우 예산을 늘리고, 그렇지 않으면 예산을 줄이는 것이다.

이렇게 예산을 최대로 배정하는 문제를 "예산을 정해놓고 이 예산이 조건에 맞는지 결정하는 문제"로 바꾸는 것이 핵심이다.

```java
import java.io.*;
import java.util.*;

public class Main {

    public static boolean check(int[] a, int d, int k) {
        int sum = 0;
        for (int v : a) {
            if (v > k) {
                sum += k;
            } else {
                sum += v;
            }
        }

        return sum <= d;
    }

    public static void main(String[] args) throws IOException {

        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));

        int N = Integer.parseInt(bf.readLine());
        int[] a = new int[N];
        StringTokenizer st = new StringTokenizer(bf.readLine());
        int tmp = 0;
        int maxv = 0;
        for (int i = 0; i < N; i++) {
            a[i] = Integer.parseInt(st.nextToken());
            tmp += a[i];
            if (maxv < a[i]) maxv = a[i];
        }
        int d = Integer.parseInt(bf.readLine());

        if (tmp <= d) {
            System.out.println(maxv);
            return;
        }

        int l = 1, r = d - N;
        while(l < r) {
            int mid = (l + r) / 2;
            if (check(a, d, mid)) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }

        System.out.println(l - 1);
    }
}
```

## 유니온 파인드

서로소 집합을 해결하는 문제이다.

어떤 집합이 어떤 집합에 속해있느냐, 독립된 영역의 갯수 등을 묻는 문제이다.

union 오퍼레이션, find 오퍼레이션으로 이루어져있고, 이들은 각각 최적화가 가능하다.

- union: 서로소 집합을 합친다. 트리 높이가 작은 쪽을 큰 쪽으로 합쳐야 최적화할 수 있다.
- find: 요소가 속한 집합을 구한다. memoization으로 최적화할 수 있다.

```java
    static HashMap<String, Integer> counts;
    static HashMap<String, String> parents;

    static String find(String x) {
        if (Objects.equals(parents.get(x), x)) {
            return x;
        } else {
            String r = find(parents.get(x));
            parents.put(x, r);
            return r;
        }
    }

    static void union(String a, String b) {
        String pa = find(a);
        String pb = find(b);
        if (!Objects.equals(pa, pb)) {
            int cpa = counts.get(pa);
            int cpb = counts.get(pb);
            if (cpa > cpb) {
                parents.put(pb, pa);
                counts.put(pa, cpa + cpb);
            } else {
                parents.put(pa, pb);
                counts.put(pb, cpa+cpb);
            }
        }
    }

```
