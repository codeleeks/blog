---
summary: 스프링에서 커서페이징을 구현하는 방법을 정리합니다.
date: 2024-09-06
title-image: 'https://raw.githubusercontent.com/codeleeks/blog/codeleeks-images/springboot/SpringBoot%20%EC%99%84%EB%B2%BD%20%EC%A0%95%EB%A6%AC/title.png'
---

## 커서 페이징

offset paging은 offset 만큼 레코드를 이동한 뒤 limit 만큼의 레코드만 잘라서 반환한다.

```sql
-- 1페이지
select * from products limit 0, 10;

-- 2페이지
select * from products limit 10, 10;
```

전체 레코드의 중간 offset을 요청한다면 forward scan이든 backward scan이든 offset만큼 이동해야 한다.
이 쿼리를 많은 사용자가 호출한다면, 성능에 문제가 있을 수 있다.

또한, 단순히 레코드 offset으로 페이징하기 때문에 레코드가 삽입/삭제/수정이 잦은 테이블인 경우에 페이징 결과물에서 중복된 데이터가 보이거나 보여야할 데이터가 사라질 수 있다.
예를 들어, 1페이지에서 1번부터 20번까지 20개의 레코드를 가져오고 난 뒤 다음 페이지로 이동하려는데, 20번 레코드를 삭제했다면 2페이지에서 21번 레코드가 안 보이게 된다.
1페이지에 해당하는 레코드가 되어버렸기 때문이다.

이러한 문제를 해결하려면 커서 페이징을 사용해야 한다.

커서 페이징은 커서 역할을 하는 컬럼을 선택해서 where이나 having 절로 필터링하는 방법이다.
```sql
-- 1페이지
select * from products limit 10;

-- 2페이지
select * from products as p where p.id > 20 limit 10;
```

## 멀티 컬럼 커서 페이징

멀티 컬럼 커서 페이징은 기본적으로 OR를 활용한다.

컬럼의 정렬 우선순위가 가장 높은 컬럼을 기준으로 정렬하고, 이 컬럼값이 같으면 다음 우선순위의 컬럼을 기준으로 정렬한다.
이는 OR 연산으로 표현할 수 있다.

```sql
-- first_name이 같으면 emp_no를 비교한다. (정렬 우선순위가 결국 커서값 비교 우선순위에 해당한다)
select * from employees as e where (e.first_name > 'Aamer' or (e.first_name = 'Aamer' and e.emp_no < '491629')) order by e.first_name, e.emp_no desc limit 10;
```

OR 연산의 단점은 인덱스를 타지 않을 수 있다는 점이다.

해결법은 제한적이다.
요구사항에서 모든 컬럼의 정렬 방향이 동일하다는 제약이 있어야 한다.
이 제약이 받아들여진다면, [커스텀 커서 방식](#커스텀-커서로-구현하기)을 고려해볼 수 있다.

## 인덱스와 커서 페이징

멀티 컬럼 커서 페이징할 때 문제는 OR가 인덱스를 타지 않는다는 점이다.

(테스트를 해보면, 인덱스를 타지 않는 것이 항상 문제가 되는 것은 아닌 것 같다.

실무에서는 요구 사항에 따라 정렬이 필요한 컬럼이 많을 수도 있고, join 등 좀 더 복잡한 쿼리가 필요할 때에는 성능이 다를 수 있다.
그래서 성능 최적화가 필요한 쿼리를 여러 가지 옵션으로 테스트해봐야 한다.
즉, 인덱스를 탈 경우와 안 탈 경우에 쿼리 성능이 어떻게 되는지 실제로 테스트해봐야 한다.

우리가 해볼 수 있는 옵션이 많다면 보다 많은 상황에 대처할 수 있기에 인덱스를 타게 하는 방법도 알아야 한다.
그래서 여기서는 인덱스를 안 타는 것이 문제라고 정의하겠다.)

이 때는 커스텀 커서를 만들어야 한다.

having도 인덱스를 타지 않으므로 where을 억지로라도 써야 한다.
where은 generated column을 조건으로 사용할 수 없다는 제약이 있어서 쿼리가 복잡해지긴 한다.

```sql
-- Aamer9999508371는 이전 페이지의 마지막 레코드의 커서값
select *, concat(e.first_name, lpad(pow(10, 10) - e.emp_no, 10, '0')) as `cursor` from employees as e where concat(e.first_name, lpad(pow(10, 10) - e.emp_no, 10, '0')) < 'Aamer9999508371' order by e.first_name, e.emp_no desc limit 10;
```
![image](https://github.com/user-attachments/assets/f6fe40a1-036e-4861-a497-4a7fce0eddba)

인덱스를 잘 탄다.

## Spring Data에서 커서 페이징 구현하기

### 싱글 컬럼일 경우 (sorting은 동적으로)

QueryDSL을 사용하여 where와 order by에 들어가는 표현식을 동적으로 처리한다.

QueryDSL의 ComparablePath를 이용하면 여러 타입의 컬럼을 커버할 수 있다.
(cursor를 반환해야 하는데, QueryDSL에서 이를 동적으로 표현하는 방법을 못 찾았다. 그래서 완벽한 커버는 아니다.)

```java
public class EmployeeEmpNoCursorPagingRepositoryImpl implements EmployeeEmpNoCursorPagingRepository {
    private final JPAQueryFactory queryFactory;

    public EmployeeEmpNoCursorPagingRepositoryImpl(EntityManager em) {
        this.queryFactory = new JPAQueryFactory(em);
    }

    @Override
    public <T extends Comparable<T>> Page<EmployeeResponse> findAll(Pageable pageable, String cursorColumn, T cursorValue, Class<T> cursorType) {

        Sort.Order orderFor = pageable.getSort().getOrderFor(cursorColumn);
        PathBuilder<? extends Employee> pathBuilder = new PathBuilder<>(employee.getType(), employee.getMetadata());

        ComparablePath<T> comparable = pathBuilder.getComparable(cursorColumn, cursorType);

        OrderSpecifier<T> order = Optional.ofNullable(orderFor)
                .filter(o -> !o.isDescending())
                .map(o -> comparable.asc())
                .orElse(comparable.desc());

        BooleanExpression cursorCond = Optional.ofNullable(orderFor)
                .map(o -> {
                    if (o.isDescending()) {
                        return comparable.lt(cursorValue);
                    } else {
                        return comparable.gt(cursorValue);
                    }
                })
                .orElse(null);

        List<EmployeeResponse> fetch = queryFactory
                .select(employee)
                .from(employee)
                .where(cursorCond)
                .orderBy(order)
                .limit(pageable.getPageSize())
                .fetch()
                .stream()
                .map(e -> EmployeeResponse.fromWithCursor(e, cursorColumn))
                .toList();

        return new PageImpl<>(fetch);
    }


    public <T extends LocalDate> Page<EmployeeResponse> findAll(Pageable pageable, String cursorColumn, T cursorValue, Class<T> cursorType) {
        Sort.Order orderFor = pageable.getSort().getOrderFor(cursorColumn);
        PathBuilder<? extends Employee> pathBuilder = new PathBuilder<>(employee.getType(), employee.getMetadata());

        DatePath<T> comparable = pathBuilder.getDate(cursorColumn, cursorType);

        OrderSpecifier<T> order = Optional.ofNullable(orderFor)
                .filter(o -> !o.isDescending())
                .map(o -> comparable.asc())
                .orElse(comparable.desc());

        BooleanExpression cursorCond = Optional.ofNullable(orderFor)
                .map(o -> {
                    if (o.isDescending()) {
                        return comparable.lt(cursorValue);
                    } else {
                        return comparable.gt(cursorValue);
                    }
                })
                .orElse(null);

        List<EmployeeResponse> fetch = queryFactory
                .select(employee)
                .from(employee)
                .where(cursorCond)
                .orderBy(order)
                .limit(pageable.getPageSize())
                .fetch()
                .stream()
                .map(e -> EmployeeResponse.fromWithCursor(e, cursorColumn))
                .toList();


        return new PageImpl<>(fetch);
    }
}



//응답 객체(DTO)
@Builder
@ToString
@EqualsAndHashCode(of = "empNo")
public class EmployeeResponse {
    private Integer empNo;
    private LocalDate birthDate;
    private String firstName;
    private String lastName;

    private Gender gender;
    private LocalDate hireDate;

    private String cursor;

    public static EmployeeResponse from(Employee employee) {
        return EmployeeResponse.builder()
                .empNo(employee.getEmpNo())
                .birthDate(employee.getBirthDate())
                .firstName(employee.getFirstName())
                .lastName(employee.getLastName())
                .gender(employee.getGender())
                .hireDate(employee.getHireDate())
                .build();
    }

    public static EmployeeResponse fromWithCursor(Employee employee, String cursorColumn) {
        EmployeeResponseBuilder builder = fill(employee);
        switch (cursorColumn) {
            case "empNo" -> builder.cursor(employee.getEmpNo().toString());
            case "hireDate" -> builder.cursor(employee.getHireDate().toString());
        }

        return builder.build();
    }

    private static EmployeeResponse.EmployeeResponseBuilder fill(Employee employee) {
        return EmployeeResponse.builder()
                .empNo(employee.getEmpNo())
                .birthDate(employee.getBirthDate())
                .firstName(employee.getFirstName())
                .lastName(employee.getLastName())
                .gender(employee.getGender())
                .hireDate(employee.getHireDate());
    }
}

```

다른 백엔드 프레임워크는 몰라도 스프링 환경에서는 커서 페이징으로 다양한 타입의 컬럼을 커버하기가 어렵다.
QueryDSL로 동적 쿼리를 작성할 수 있지만, 결국 **컬럼의 타입**이 문제가 된다.

- LocalDate는 Comparable하지 않기 때문에 Comparable을 지원하는 Integer, Long, String 등의 타입을 처리하는 메서드와 LocalDate 타입을 처리하는 메서드를 분리했다.
- cursor 값을 반환하기 위해서 `EmployeeResponse` 객체를 생성할 때 `switch-case`로 컬럼 이름에 따라 커서에 들어가는 값을 달리 해줬다.

그러나 offset paging을 사용하면 타입에 상관없어진다.

```java
public interface EmployeeRepositoryV1 extends PagingAndSortingRepository<Employee, Integer> {
}
```

간단한 인터페이스 하나면 충분하다. 

커서 페이징처럼 컬럼을 보는 게 아니라 그냥 레코드 오프셋만 따지기 때문에 컬림이 필요가 없다.
그래서 컬럼 타입에 대해 신경쓰지 않아도 된다.
정렬도 `PageRequest` 객체를 만들 때 `Sort` 객체로 넣어주면 된다.

### 멀티 컬럼일 경우 (sorting은 동적으로)

#### `OR`로 구현하기

```java
public class EmployeeEmpNoAndFirstNameCursorPagingRepositoryImpl implements EmployeeEmpNoAndFirstNameCursorPagingRepository {
    private final JPAQueryFactory queryFactory;

    public EmployeeEmpNoAndFirstNameCursorPagingRepositoryImpl(EntityManager em) {
        this.queryFactory = new JPAQueryFactory(em);
    }

    @Override
    public Page<EmployeeResponse> findAll(Pageable pageable, Integer empNo, String firstName) {
        boolean isEmpNoDescending = Optional.ofNullable(pageable.getSort().getOrderFor("empNo"))
                .map(Sort.Order::isDescending)
                .orElse(true);


        boolean isFirstNameDescending = Optional.ofNullable(pageable.getSort().getOrderFor("firstName"))
                .map(Sort.Order::isDescending)
                .orElse(false);


        List<EmployeeResponse> fetch = queryFactory.selectFrom(employee)
                .where(
                        orCursor(empNo, firstName, isEmpNoDescending, isFirstNameDescending)
                )
                .orderBy(isFirstNameDescending ? employee.firstName.desc() : employee.firstName.asc())
                .orderBy(isEmpNoDescending ? employee.empNo.desc() : employee.empNo.asc())
                .limit(pageable.getPageSize())
                .fetch()
                .stream()
                .map(EmployeeResponse::from)
                .toList();

        return new PageImpl<>(fetch);
    }

    private BooleanExpression orCursor(Integer empNo, String firstName, boolean isEmpNoDescending, boolean isFirstNameDescending) {
        if (empNo == null && firstName == null) {
            return null;
        }

        BooleanExpression expression = null;

        if (isFirstNameDescending) {
            expression = employee.firstName.lt(firstName);
        } else {
            expression = employee.firstName.gt(firstName);
        }

        if (isEmpNoDescending) {
            expression = expression.or(
                    employee.firstName.eq(firstName)
                            .and(
                                    employee.empNo.lt(empNo)
                            )
            );
        } else {
            expression = expression.or(
                    employee.firstName.eq(firstName)
                            .and(
                                    employee.empNo.gt(empNo)
                            )
            );
        }


        return expression;
    }
}

//테스트
@Test
public void pagingMultipleColumns() throws Exception {
    List<EmployeeResponse> content = serviceV3.findPageContents(PageRequest.of(2, 10), null, null)
            .getContent();
    content.forEach(e -> log.info(e.toString()));

    List<EmployeeResponse> content2 = serviceV3.findPageContents(PageRequest.of(2, 10), 491629, "Aamer")
            .getContent();
    content2.forEach(e -> log.info(e.toString()));

    List<EmployeeResponse> content3 = serviceV3.findPageContents(PageRequest.of(2, 10, Sort.by("empNo").ascending().and(Sort.by("firstName").descending())), null, null)
            .getContent();

    content3.forEach(e -> log.info(e.toString()));

    List<EmployeeResponse> content4 = serviceV3.findPageContents(PageRequest.of(1500, 10, Sort.by("empNo").ascending().and(Sort.by("firstName").descending())), 241525, "Yechezkel")
            .getContent();

    content4.forEach(e -> log.info(e.toString()));

}

```

#### 커스텀 커서로 구현하기

이 구현은 모든 컬럼의 정렬 방향이 동일하다는 제약이 필요하다.

그렇지 않으면 인덱스를 타게 만들기 어렵다(정렬 방향의 경우의 수마다 인덱스를 만들어야 한다)

물론 동적으로 컬럼을 선택해서 커스텀 커서로 만들기는 어렵다. 
정해진 요구사항에 따라 적절한 컬럼이 정적으로 선택되어야 한다.
(예를 들어, 최신순이면 modified_date를 기준으로, 추천순이면 likes, comments 등 추천 로직에 필요한 컬럼을 기준으로 미리 작성해놔야 한다.
이러한 정렬 방법을 QueryDSL에서는 `OrderSpecifier`로 정의한다.
따라서 정렬 방법에 따라 적절한 OrderSpecifier를 사용하면 된다.)

예제 코드에서는 하나의 정렬 방법만 사용한다.

```java
package test.cursorpaging.domain.repository.v4;

import com.querydsl.core.types.dsl.StringExpression;
import com.querydsl.core.types.dsl.StringExpressions;
import com.querydsl.jpa.impl.JPAQuery;
import com.querydsl.jpa.impl.JPAQueryFactory;
import jakarta.annotation.Nullable;
import jakarta.persistence.EntityManager;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import test.cursorpaging.domain.repository.EmployeeResponse;
import test.cursorpaging.domain.repository.QEmployeeResponse;

import java.util.List;

import static test.cursorpaging.domain.QEmployee.employee;

public class EmployeeCustomCursorPagingRepositoryImpl implements EmployeeCustomCursorPagingRepository {
    private final JPAQueryFactory queryFactory;

    public EmployeeCustomCursorPagingRepositoryImpl(EntityManager em) {
        this.queryFactory = new JPAQueryFactory(em);
    }

    //    커서로 정할 컬럼은 정적으로 정해짐. (empNo, firstName)
    @Override
    public Page<EmployeeResponse> findAll(Pageable pageable, @Nullable String cursorValue, boolean isAscending) {
        JPAQuery<EmployeeResponse> query = queryFactory
                .select(new QEmployeeResponse(
                        employee.empNo,
                        employee.birthDate,
                        employee.firstName,
                        employee.lastName,
                        employee.gender,
                        employee.hireDate,
                        getCursor()
                        )
                )
                .from(employee);

        if (isAscending) {
            query = query
                    .where(cursorValue != null ? getCursor().gt(cursorValue) : null)
                    .orderBy(employee.firstName.asc(), employee.empNo.asc());
        } else {
            query = query
                    .where(cursorValue != null ? getCursor().lt(cursorValue) : null)
                    .orderBy(employee.firstName.desc(), employee.empNo.desc());
        }

        List<EmployeeResponse> fetch = query
                .limit(pageable.getPageSize())
                .fetch();


        return new PageImpl<>(fetch);
    }

    private StringExpression getCursor() {
        return employee.firstName.concat(StringExpressions.lpad(employee.empNo.stringValue(), 10, '0'));
    }
}

//테스트
@Test
public void pagingCustomCursor() throws Exception {
    List<EmployeeResponse> content = serviceV4.findPageContents(PageRequest.of(2, 10), null, true)
            .getContent();

    content.forEach(e -> log.info(e.toString()));

    List<EmployeeResponse> content2 = serviceV4.findPageContents(PageRequest.of(2, 10), "Aamer9999508371", true)
            .getContent();

    content2.forEach(e -> log.info(e.toString()));
}
```

커스텀 커서의 장점은 인덱스를 탄다는 점이다.

```sql
explain select *, concat(e.first_name, lpad(e.emp_no, 10, '0')) as `cursor` from employees as e where concat(e.first_name, lpad(e.emp_no, 10, '0')) > 'Aamer9999508371' order by e.first_name, e.emp_no limit 10;
```

![image](https://github.com/user-attachments/assets/ff28b6c7-5ef6-46a7-ab5b-cacf58ecfc60)

## 결론

||offset paging|cursor paging|
|---|---|---|
|개발 편의성|편리함|멀티 컬럼으로 갈수록 복잡해짐|
|유즈케이스|소량의 데이터를 다루고, 페이지 정확성에 덜 민감한 백오피스|변경이 잦고 대량의 데이터를 다루는 B2C 서비스|
|한계|대량의 데이터에 대한 대량의 요청을 감당하지 못할 수 있음|여러 컬럼에 대한 비통일된 정렬 방향이 필요한 경우 개발이 어렵고 성능도 안 나올 수도 있음(인덱스를 활용하지 못할 가능성이 높기 때문에)|


## 참고

https://velog.io/@minsangk/%EC%BB%A4%EC%84%9C-%EA%B8%B0%EB%B0%98-%ED%8E%98%EC%9D%B4%EC%A7%80%EB%84%A4%EC%9D%B4%EC%85%98-Cursor-based-Pagination-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0#%EC%BC%80%EC%9D%B4%EC%8A%A4-price-desc-id-desc-%EC%BB%A4%EC%8A%A4%ED%85%80-cursor-%EC%83%9D%EC%84%B1

https://stackoverflow.com/questions/38017054/mysql-cursor-based-pagination-with-multiple-columns

https://velog.io/@znftm97/%EC%BB%A4%EC%84%9C-%EA%B8%B0%EB%B0%98-%ED%8E%98%EC%9D%B4%EC%A7%80%EB%84%A4%EC%9D%B4%EC%85%98Cursor-based-Pagination%EC%9D%B4%EB%9E%80-Querydsl%EB%A1%9C-%EA%B5%AC%ED%98%84%EA%B9%8C%EC%A7%80-so3v8mi2
