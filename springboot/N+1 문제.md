## N+1 문제란?

하나의 쿼리로 한 개의 엔티티를 가져올 때 연관된 엔티티를 가져오느라 N번의 쿼리가 실행되는 문제이다.

엔티티의 레코드가 많을 수록 연관된 엔티티의 레코드도 많을 확률이 높기 때문에 많은 쿼리가 실행되면서 성능 저하를 일으킨다.

모든 연관 관계 상황에서 발생할 수 있다.(다대일, 일대다 모두 발생 가능)

또한, 즉시로딩/지연로딩과 무관하게 발생할 수 있다.
즉시로딩과 지연로딩의 차이는 단지 언제 쿼리가 나가느냐의 문제이다.
즉시로딩은 엔티티를 가져올 때 바로 발생하며, 지연로딩은 필드에 접근할 때 발생한다.

```java
@Entity
public class Member {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private Integer age;

    @ManyToOne(fetch = FetchType.EAGER, cascade = CascadeType.ALL)
    @JoinColumn(name = "team_id")
    private Team team;
}

String jpql = "select m from Member m";
List<Member> resultList = em.createQuery(jpql, Member.class)
        .getResultList();
```

```bash
Hibernate: 
    /* select
        m 
    from
        Member m */ select
            m1_0.id,
            m1_0.city,
            m1_0.street,
            m1_0.zipcode,
            m1_0.age,
            m1_0.name,
            m1_0.team_id 
        from
            Member m1_0
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
```

## 해결방안1 - fetch join

두 엔티티가 거의 항상 같이 사용된다면 페치 조인으로 한 번에 다 가져오는 것이 나을 수 있다.
```java
String jpql = "select m from Member m join fetch m.team";
List<Member> resultList = em.createQuery(jpql, Member.class)
        .getResultList();
```

```bash
Hibernate: 
    /* select
        m 
    from
        Member m 
    join
        
    fetch
        m.team */ select
            m1_0.id,
            m1_0.city,
            m1_0.street,
            m1_0.zipcode,
            m1_0.age,
            m1_0.name,
            t1_0.id,
            t1_0.name 
        from
            Member m1_0 
        join
            Team t1_0 
                on t1_0.id=m1_0.team_id
```

### 한계

`@OneToMany` 관계에서 페이징할 수 없다.
양방향 관계를 맺고, 다대일처럼 다쪽 엔티티 중심으로 쿼리를 짜야 한다.

```java
String jpql = "select m from Member m join fetch m.team";
List<Member> resultList = em.createQuery(jpql, Member.class)
        .getResultList();
        .setFirstResult(9) //인덱스
        .setMaxResults(5) //갯수
```

## 해결방안2 - batch size

N+1에서 N을 줄이는 방법이다. (N / batch size로 줄인다)

엔티티 필드에 접근할 때 `in` 키워드로 매칭되는 여러 레코드를 가져온다.
엔티티는 페이징해서 가져오고, 가져온 레코드의 기본키를 `in` 키워드에 넣는다.
`in` 키워드가 받아줄 수 있는 갯수는 batch size이며, 페이징하여 가져온 레코드의 기본키 갯수만큼 넣는다.(기본키 갯수가 더 많아서 초과할 경우 다 채울 때까지 쿼리를 더 실행한다)

||동작|
|---|---|
|batch size > 페이징 갯수|페이징 갯수만큼 `in`에 채워서 실행|
|batch size < 페이징 갯수|페이징 갯수를 채울 만큼 쿼리를 더 실행|

```java
@Entity
public class Team {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    @BatchSize(size = 10)
    @OneToMany(fetch = FetchType.LAZY, cascade = CascadeType.ALL, orphanRemoval = true)
    @JoinColumn(name = "team_id")
    private List<Member> members = new ArrayList<>();
}

String jpql = "select t from Team t";

List<Team> teams = em.createQuery(jpql, Team.class)
        .setFirstResult(9)
        .setMaxResults(5)
        .getResultList();
```

```bash
Hibernate: 
    /* select
        t 
    from
        Team t */ select
            t1_0.id,
            t1_0.name 
        from
            Team t1_0 
        offset
            ? rows 
        fetch
            first ? rows only
team.getName() = team10
Hibernate: 
    select
        m1_0.team_id,
        m1_0.id,
        m1_0.city,
        m1_0.street,
        m1_0.zipcode,
        m1_0.age,
        m1_0.name 
    from
        Member m1_0 
    where
        m1_0.team_id in (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
```
