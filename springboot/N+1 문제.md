---
summary: N+1 문제를 정리합니다.
date: 2024-07-17
title-image: 'https://raw.githubusercontent.com/codeleeks/blog/codeleeks-images/springboot/N%2B1%20%EB%AC%B8%EC%A0%9C/title.png'
---


## N+1 문제란?

하나의 쿼리로 한 개의 엔티티를 가져올 때 연관된 엔티티를 가져오느라 N번의 쿼리가 실행되는 문제이다.

엔티티의 레코드가 많을 수록 연관된 엔티티의 레코드도 많을 확률이 높기 때문에 많은 쿼리가 실행되면서 성능 저하를 일으킨다.

모든 연관 관계 상황에서 발생할 수 있다.(다대일, 일대다 모두 발생 가능)

또한, 즉시로딩/지연로딩과 무관하게 발생할 수 있다.
즉시로딩과 지연로딩의 차이는 단지 언제 쿼리가 나가느냐의 문제이다.
즉시로딩은 엔티티를 가져올 때 바로 발생하며, 지연로딩은 필드에 접근할 때 발생한다.

```java
@Entity
public class Member {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private Integer age;

    @ManyToOne(fetch = FetchType.EAGER, cascade = CascadeType.ALL)
    @JoinColumn(name = "team_id")
    private Team team;
}

String jpql = "select m from Member m";
List<Member> resultList = em.createQuery(jpql, Member.class)
        .getResultList();
```

```bash
Hibernate: 
    /* select
        m 
    from
        Member m */ select
            m1_0.id,
            m1_0.city,
            m1_0.street,
            m1_0.zipcode,
            m1_0.age,
            m1_0.name,
            m1_0.team_id 
        from
            Member m1_0
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
Hibernate: 
    select
        t1_0.id,
        t1_0.name 
    from
        Team t1_0 
    where
        t1_0.id=?
```

## 해결방안1 - fetch join

두 엔티티가 거의 항상 같이 사용된다면 페치 조인으로 한 번에 다 가져오는 것이 나을 수 있다.
```java
String jpql = "select m from Member m join fetch m.team";
List<Member> resultList = em.createQuery(jpql, Member.class)
        .getResultList();
```

```bash
Hibernate: 
    /* select
        m 
    from
        Member m 
    join
        
    fetch
        m.team */ select
            m1_0.id,
            m1_0.city,
            m1_0.street,
            m1_0.zipcode,
            m1_0.age,
            m1_0.name,
            t1_0.id,
            t1_0.name 
        from
            Member m1_0 
        join
            Team t1_0 
                on t1_0.id=m1_0.team_id
```

### 한계

`@OneToMany` 관계에서 페이징할 수 없다.
양방향 관계를 맺고, 다대일처럼 다쪽 엔티티 중심으로 쿼리를 짜야 한다.

```java
String jpql = "select m from Member m join fetch m.team";
List<Member> resultList = em.createQuery(jpql, Member.class)
        .getResultList();
        .setFirstResult(9) //인덱스
        .setMaxResults(5) //갯수
```

## 해결방안2 - batch size

```yaml
spring:
  jpa:
    properties:
      hibernate:
        default_batch_fetch_size: 100
```

N+1에서 N을 줄이는 방법이다. (N / batch size로 줄인다)

엔티티 필드에 접근할 때 `in` 키워드로 매칭되는 여러 레코드를 가져온다.
엔티티는 페이징해서 가져오고, 가져온 레코드의 기본키를 `in` 키워드에 넣는다.
`in` 키워드가 받아줄 수 있는 갯수는 batch size이며, 페이징하여 가져온 레코드의 기본키 갯수만큼 넣는다.(기본키 갯수가 더 많아서 초과할 경우 다 채울 때까지 쿼리를 더 실행한다)

||동작|
|---|---|
|batch size > 페이징 갯수|페이징 갯수만큼 `in`에 채워서 실행|
|batch size < 페이징 갯수|페이징 갯수를 채울 만큼 쿼리를 더 실행|

더 정확히 말하면 1차 캐시에 엔티티가 없으면 배치 쿼리를 실행한다.

batch_size = 5, 페이지 사이즈 = 10일 때, 루트 엔티티 10개를 가져온다고 하자.
각 루트 엔티티의 연관 엔티티를 가져오려고 getter를 호출할 때 in 쿼리에 5개의 루트 엔티티 id가 들어간다.
이는 0~4번의 루트 엔티티의 연관 엔티티를 하나의 쿼리로 가져오는 것이다.
그래서 1~4번의 루트엔티티가 연관 엔티티에 대한 getter를 호출함에도 별도의 쿼리는 나가지 않는다.
이후 5번 루트 엔티티가 연관엔티티에 대한 getter를 호출할 때 5~9번의 연관 엔티티를 in 쿼리로 가져온다.
마찬가지로 6~9번의 루트엔티티는 getter를 호출해도 별도의 쿼리가 나가지 않는다.

```java
@Entity
public class Team {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    @BatchSize(size = 10)
    @OneToMany(fetch = FetchType.LAZY, cascade = CascadeType.ALL, orphanRemoval = true)
    @JoinColumn(name = "team_id")
    private List<Member> members = new ArrayList<>();
}

String jpql = "select t from Team t";

List<Team> teams = em.createQuery(jpql, Team.class)
        .setFirstResult(9)
        .setMaxResults(5)
        .getResultList();
```

```bash
Hibernate: 
    /* select
        t 
    from
        Team t */ select
            t1_0.id,
            t1_0.name 
        from
            Team t1_0 
        offset
            ? rows 
        fetch
            first ? rows only
team.getName() = team10
Hibernate: 
    select
        m1_0.team_id,
        m1_0.id,
        m1_0.city,
        m1_0.street,
        m1_0.zipcode,
        m1_0.age,
        m1_0.name 
    from
        Member m1_0 
    where
        m1_0.team_id in (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
```

## 해결방안3 - jpql에서 DTO로 만들기

조인된 결과를 DTO로 만드는 방법이다.
`@ManyToOne` 엔티티를 기준으로 조인을 건다. (그래야 페이징이 가능하다.)

```java
public class MemberTeam {
    private Member member;
    private Team team;

    public MemberTeam(Member member, Team team) {
        this.member = member;
        this.team = team;
    }

    public Member getMember() {
        return member;
    }

    public Team getTeam() {
        return team;
    }
}

String jpql = "select new hellojpa.MemberTeam(m, t) from Member m join m.team as t";
List<MemberTeam> resultList = em.createQuery(jpql, MemberTeam.class)
        .getResultList();
```

`batch size` 방법과 차이는 필요한 배치 사이즈를 꼭 맞출 수 있다는 점이다.
`in` 쿼리에 어레이를 파라미터로 넣어서 사용할 수 있기 때문이다.

```java
public List<OrderQueryDto> findOrderQueryDtoOptimized() {
    List<OrderQueryDto> orders = findOrders();

    Map<Long, List<OrderItemQueryDto>> orderItemsOptimized = findOrderItemsOptimized(orders.stream().map(OrderQueryDto::getOrderId).toList());
    orders.forEach(o -> {
        o.setOrderItems(
            orderItemsOptimized.get(o.getOrderId())
        );
    });

    return orders;
}

public Map<Long, List<OrderItemQueryDto>> findOrderItemsOptimized(List<Long> orderIds) {
    //in 쿼리에 어레이를 넣는다. 그래서 배치 사이즈를 꼭 맞출 수 있다.
    String jpql = "select new jpabook.jpashop.repository.order.simplequery.OrderItemQueryDto(oi.order.id, i.name, oi.orderPrice, oi.count) from OrderItem oi join oi.item i where oi.order.id in :orderIds";
    List<OrderItemQueryDto> orderItems = em.createQuery(jpql, OrderItemQueryDto.class)
            .setParameter("orderIds", orderIds)
            .getResultList();

    return orderItems.stream()
            .collect(Collectors.groupingBy(OrderItemQueryDto::getOrderId));
}
```

## 전략 선택 가이드

기본적으로 `@ManyToOne`으로만 설계하고, fetch join 전략을 사용한다.
`@OneToMany` 필드로 조회해야 할 경우 `batch size`를 설정한다.

DTO 전략은 배치 사이즈를 꼭 맞출 수 있다는 점이 `batch size` 설정과의 차이로 보인다.
이 차이가 성능에 영향을 미치는 경우에는 DTO 전략을 사용한다.
