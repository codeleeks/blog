## 테스트 환경

MySQL 8
JPA 3.1.0
Spring Boot 3.3.3

## 팬텀 리드

### READ_COMITTED부터 발생.

```java
@Test
public void phantomRead() throws Exception {
    int n = 2;
    ExecutorService executorService = Executors.newFixedThreadPool(n);

    Future<?> findResult = executorService.submit(() -> {
        service.find();
    });

    executorService.submit(() -> {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        service.save("phantom");
        log.info("finished");
    });


    findResult.get();
}
@Service
@Transactional(isolation = Isolation.READ_COMMITTED)
@Slf4j
public class TestEntityService {
    private final EntityManager em;

    public void find() {
        em.createQuery("select t from TestEntity t where t.id >= 3", TestEntity.class)
                .getResultList()
                .forEach(t -> log.info(t.toString()));

        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        em.createQuery("select t from TestEntity t where t.id >= 3", TestEntity.class)
                .getResultList()
                .forEach(t -> log.info(t.toString()));
    }

}
```
```bash
Hibernate: 
    select
        te1_0.id,
        te1_0.name 
    from
        TestEntity te1_0 
    where
        te1_0.id>=3
2024-09-19T15:30:17.618+09:00  INFO 4980 --- [transaction] [pool-1-thread-1] t.transaction.service.TestEntityService  : TestEntity(id=3, name=a2)
2024-09-19T15:30:17.618+09:00  INFO 4980 --- [transaction] [pool-1-thread-1] t.transaction.service.TestEntityService  : TestEntity(id=4, name=a3)
2024-09-19T15:30:17.618+09:00  INFO 4980 --- [transaction] [pool-1-thread-1] t.transaction.service.TestEntityService  : TestEntity(id=5, name=a4)
Hibernate: 
    insert 
    into
        TestEntity
        (name) 
    values
        (?)
2024-09-19T15:30:18.218+09:00  INFO 4980 --- [transaction] [pool-1-thread-2] t.t.transaction.TransactionTest          : finished
Hibernate: 
    select
        te1_0.id,
        te1_0.name 
    from
        TestEntity te1_0 
    where
        te1_0.id>=3
2024-09-19T15:30:19.631+09:00  INFO 4980 --- [transaction] [pool-1-thread-1] t.transaction.service.TestEntityService  : TestEntity(id=3, name=a2)
2024-09-19T15:30:19.631+09:00  INFO 4980 --- [transaction] [pool-1-thread-1] t.transaction.service.TestEntityService  : TestEntity(id=4, name=a3)
2024-09-19T15:30:19.631+09:00  INFO 4980 --- [transaction] [pool-1-thread-1] t.transaction.service.TestEntityService  : TestEntity(id=5, name=a4)
2024-09-19T15:30:19.631+09:00  INFO 4980 --- [transaction] [pool-1-thread-1] t.transaction.service.TestEntityService  : TestEntity(id=6, name=phantom)
```

마지막에 phantom이라는 이름의 레코드가 조회되었다. 팬텀 리드가 발생했다.
READ_COMITTED에서는 팬텀 리드가 발생한다.

### REPEATABLE_READ에서는 락을 걸 때 발생한다.

REPEATABLE_READ는 MVCC를 통해 팬텀리드를 방지하는데, 락을 걸게 되면 MVCC로 동작하지 않는다.
MySQL에서는 갭락이라는 개념이 있다.
범위 쿼리시 해당 범위에 들어오는 인서트 쿼리를 blocking한다.

```java
@Test
  public void phantomRead() throws Exception {
      int n = 2;
      ExecutorService executorService = Executors.newFixedThreadPool(n);

      Future<?> findResult = executorService.submit(() -> {
          service.find();
      });

      executorService.submit(() -> {
          try {
              Thread.sleep(1000);
          } catch (InterruptedException e) {
              throw new RuntimeException(e);
          }
          service.save("phantom");
          log.info("finished");
      });


      findResult.get();
  }

@Service
@Transactional(isolation = Isolation.REPEATABLE_READ)
@Slf4j
public class TestEntityService {
    private final EntityManager em;

    public void find() {
        em.createQuery("select t from TestEntity t where t.id >= 3", TestEntity.class)
                .setLockMode(LockModeType.PESSIMISTIC_READ)
                .getResultList()
                .forEach(t -> log.info(t.toString()));

        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        em.createQuery("select t from TestEntity t where t.id >= 3", TestEntity.class)
                .setLockMode(LockModeType.PESSIMISTIC_READ)
                .getResultList()
                .forEach(t -> log.info(t.toString()));

        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
}
```
```bash
Hibernate: 
    select
        te1_0.id,
        te1_0.name 
    from
        TestEntity te1_0 
    where
        te1_0.id>=3 for share
2024-09-19T15:17:08.489+09:00  INFO 2828 --- [transaction] [pool-1-thread-1] t.transaction.service.TestEntityService  : TestEntity(id=3, name=a2)
2024-09-19T15:17:08.489+09:00  INFO 2828 --- [transaction] [pool-1-thread-1] t.transaction.service.TestEntityService  : TestEntity(id=4, name=a3)
2024-09-19T15:17:08.489+09:00  INFO 2828 --- [transaction] [pool-1-thread-1] t.transaction.service.TestEntityService  : TestEntity(id=5, name=a4)
Hibernate: 
    insert 
    into
        TestEntity
        (name) 
    values
        (?)
Hibernate: 
    select
        te1_0.id,
        te1_0.name 
    from
        TestEntity te1_0 
    where
        te1_0.id>=3 for share
2024-09-19T15:17:10.499+09:00  INFO 2828 --- [transaction] [pool-1-thread-1] t.transaction.service.TestEntityService  : TestEntity(id=3, name=a2)
2024-09-19T15:17:10.499+09:00  INFO 2828 --- [transaction] [pool-1-thread-1] t.transaction.service.TestEntityService  : TestEntity(id=4, name=a3)
2024-09-19T15:17:10.499+09:00  INFO 2828 --- [transaction] [pool-1-thread-1] t.transaction.service.TestEntityService  : TestEntity(id=5, name=a4)
2024-09-19T15:17:12.505+09:00  INFO 2828 --- [transaction] [pool-1-thread-2] t.t.transaction.TransactionTest          : finished
```

테스트 코드는 인서트 전에 락을 잡았기 때문에 갭락이 적용된다.
갭락으로 인해 인서트 쿼리가 적용이 안 되고, 락을 잡은 트랜잭션이 끝날 때까지 기다린다. (그래서 `finsished`라는 로그가 마지막에 출력된다.)

## 논리피터블 리드

READ_COMMITED부터 발생한다.

```java
@Test
public void nonRepeatableRead() throws Exception {
    int n = 2;
    ExecutorService executorService = Executors.newFixedThreadPool(n);

    Future<?> findResult = executorService.submit(() -> {
        service.findByName("nonRepeatableRead");
    });

    executorService.submit(() -> {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        service.update(5L, "nonRepeatableRead");
    });

    findResult.get();
}

@Service
@Transactional(isolation = Isolation.READ_COMMITTED)
@Slf4j
public class TestEntityService {
    private final EntityManager em;

    public void findByName(String name) {
        try {
            TestEntity v = em.createQuery("select t from TestEntity t where name = :name", TestEntity.class)
                    .setParameter("name", name)
                    .getSingleResult();
            log.info(v.toString());
        } catch (Exception e) {

        }

        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        try {
            TestEntity v = em.createQuery("select t from TestEntity t where name = :name", TestEntity.class)
                    .setParameter("name", name)
                    .getSingleResult();
            log.info(v.toString());
        } catch (Exception e) {

        }
    }

    public void update(Long id, String name) {
        em.createQuery("update TestEntity t set t.name = :name where id = :id")
                .setParameter("name", name)
                .setParameter("id", id)
                .executeUpdate();
    }
}
```
```bash
Hibernate: 
    select
        te1_0.id,
        te1_0.name 
    from
        TestEntity te1_0 
    where
        te1_0.name=?
Hibernate: 
    update
        TestEntity te1_0 
    set
        name=? 
    where
        te1_0.id=?
Hibernate: 
    select
        te1_0.id,
        te1_0.name 
    from
        TestEntity te1_0 
    where
        te1_0.name=?
2024-09-19T15:41:39.963+09:00  INFO 10356 --- [transaction] [pool-1-thread-1] t.t.transaction.TransactionTest          : TestEntity(id=5, name=nonRepeatableRead)
```

