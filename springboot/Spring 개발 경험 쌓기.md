## 디렉토리 구조

- web/request
  - request 객체. 
  - controller 메서드의 파라미터로 사용. `toEntity()` 메서드를 통해 entity로 변환하여 서비스 레이어에 전달.

## 읽기 컨트롤러와 쓰기 컨트롤러 분리

`@RequestMapping`을 사용한다.

view와 edit을 분리하여 두 개의 컨트롤러로 관리할 때 view는 `method = RequestMethod.GET` 으로 처리, edit은 디폴트로 처리하면 method에 따라 매핑되는 컨트롤러가 달라진다.


## 빌더와 초기화

엔티티가 컬렉션 필드를 가질 때 빌더를 쓰면 컬렉션 필드 정의시 초기화한 로직이 덮어쓰여질 수 있다.

```java
Category category = category.builder()
	.name("name")
	.build();
```
이렇게 하면 category의 children 컬렉션이 null로 초기화되어 버린다. (빌더의 필드로 초기화되기 때문에)

해결법은 `@Builder.Default`이다. 이 어노테이션을 지정하면 작성한 초기화 코드가 빌더 로직에 들어간다.


## @Transactional과 delete

테스트코드에서 @Transactional을 사용하면 delete 쿼리가 나가지 않는다.
findBy 계열의 메서드로 확인하면 찾지 못하는 것을 보아 1차 캐시에선 지워지는 것 같다.
그러나 쿼리 로그에서는 delete 쿼리가 보이지 않는다.
어차피 롤백되기 때문일까?

문제는 delete 쿼리가 실제로 나갈 때 생기는 문제를 테스트 코드에서 걸러내지 못한다는 점이다.
delete 쿼리에서 대표적으로 발생하는 문제는 외래키 무결성 조건을 위반하는 것이다.
다시 말해, 참조를 받는 엔티티가 삭제되면 참조하는 엔티티도 삭제되어야 한다. (팀이 삭제되면 멤버도 삭제되어야 한다.)

## @ManyToOne의 한계?

@ManyToOne의 한계는 두 가지이다.

- 속해야 하는 엔티티를 조회해야 한다.
  - 멤버는 팀에 속한다. 멤버를 추가하는 메서드는 멤버의 상세 내용을 데이터베이스에 등록하고, 팀에 멤버를 추가해야 한다. 이 때 팀를 조회해야 한다.
    - 멤버 레포지토리에 팀을 조회하는 메서드를 만든다. JPQL을 사용하면 된다.
- 자신을 참조하는 엔티티도 같이 지워줘야 한다.
  - 포스트는 카테고리에 속하면서도, 코멘트에 참조된다.
  - 카테고리를 지우고 싶어도 포스트가 있으면 못 지운다는 정책은 어느 정도 말이 된다.
  - 반면, 포스트를 지우고 싶어도 코멘트가 있으면 못 지운다는 정책은 말이 되지 않는다.
    -  이 경우에는 포스트를 삭제하면 그와 연관된 코멘트들도 같이 지워져야 한다.
    - 만약 포스트가 @OneToMany로 코멘트를 들고 있다면 컬렉션을 지워버리면 끝난다. (물론 cascade를 설정해야 한다)
    - 하지만 @ManyToOne 구조로는 포스트가 코멘트 관련 서비스나 레포지토리를 참조하고, 포스트를 삭제하기 전에 코멘트를 삭제해야 한다.
    - 그러나 반대로 생각해보자. @OneToMany 구조에서는 코멘트를 삭제하려면 포스트를 알아야 한다. 업데이트할 때도 마찬가지이다. 컬렉션에서 꺼내서 수정을 하든 컬렉션에서 삭제를 하든, 컬렉션을 조회하려면 먼저 포스트를 알아야 한다.

