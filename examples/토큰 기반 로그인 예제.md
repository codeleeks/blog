---
summary: 토큰 기반 로그인 기능을 구현한 프론트엔드/백엔드 예제입니다.
date: 2024-07-10
title-image: 'https://raw.githubusercontent.com/codeleeks/blog/codeleeks-images/examples/%ED%86%A0%EA%B7%BC%20%EA%B8%B0%EB%B0%98%20%EB%A1%9C%EA%B7%B8%EC%9D%B8%20%EC%98%88%EC%A0%9C/title.png'
---

## 세션 인증 방식과 토큰 인증 방식

||세션 인증 방식|토큰 인증 방식|
|---|---|---|
|원리|로그인 성공시 서버에서 세션을 생성하고 cookie 형태로 반환한다. <br />이후 모든 클라이언트 요청에 쿠키가 포함된다.|로그인 성공시 서버에서 토큰을 발행하고, 클라이언트는 권한이 필요한 요청을 할 때 토큰을 넣어 보낸다|
|저장 위치|세션은 서버의 메모리에 저장되며, 쿠키는 브라우저에 저장된다|토큰은 서버의 DB나 메모리에 저장가능하며(개발자의 몫), 브라우저에서는 로컬스토리지나 쿠키를 이용한다|
|장점|서버는 세션을 임의로 무효화할 수 있다|DB에 저장할 경우 세션 인증 방식보다는 서버의 부하를 줄일 수 있다.|
|단점|서버의 메모리에 저장되기 때문에 동시에 많은 사용자가 로그인한 경우 메모리 부하가 온다|서버는 이미 발급한 토큰을 자체적으로 무효화할 수 있는 방법이 없다|

일반적으로 토큰 인증 방식이 사용된다고 한다.

서버의 부하를 줄일 수 있다는 점이 매력적이고, 단점으로 지적된 토큰 무효화 불가능에 대해선 해결책이 있기 때문이다. (추후 예제로 살펴본다)

## JWT (JSON Web Token) 인증 방식

JWT 인증 방식은 토큰 인증 방식의 대표적인 구현체이다.

JWT는 JSON 형태의 구조를 갖고, .(period)로 구분된 세 개의 필드(Header, Payload, Signature)로 구성된다.

![image](https://github.com/codeleeks/blog/assets/166087781/836c3d3e-deb5-444c-9a82-d55cd0e5a65c)

json의 키-값의 쌍을 클레임이라고 부른다.

Payload에는 예약된 클레임과 커스텀 클레임을 넣을 수 있는데,

예약된 클레임은 `iss`, 'exp' 등이 있다.
- `iss`: issuer
- `exp`: expiration time

더 알아보려면, [Registered Claims](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1)를 참조하자.

커스텈 클레임은 원하는 값을 키-밸류 형태로 정의하면 된다.

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022
}
```

## JWT 인증 기반 로그인 예제

프론트엔드는 `React`를 사용했고, 백엔드는 `Spring Boot`를 사용했다.

### Normal Case

![image](https://github.com/user-attachments/assets/15819603-e930-49a0-8f7a-cf63f82541a4)



mermaid code
```
sequenceDiagram
    Frontend->>+Backend: login(id, pwd)
    Backend->>-Frontend: return refresh token, access token (wii be saved to browser store)
    Frontend->>+Backend: /items (with access-token only)
    Backend->>-Frontend: list of items (success)
```

### access token이 만료된 케이스

![image](https://github.com/user-attachments/assets/61584609-7985-47cc-92e8-33df021fd4b0)


유효한 refresh token을 서버에 보내면 서버가 새 access token과 refresh token을 재발급한다.([refresh token rotation](https://velog.io/@chuu1019/Access-Token%EA%B3%BC-Refresh-Token%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EA%B3%A0-%EC%99%9C-%ED%95%84%EC%9A%94%ED%95%A0%EA%B9%8C))

`/refresh` API에서 refresh token의 유효성을 확인하고 새 토큰들을 발급한다.

memmaid code
```
sequenceDiagram
    Frontend->>+Backend: /items (the request required the authentication)
    Backend->>-Frontend: return UNAUTHORIZED response
    Frontend->>+Backend: /refresh (with refresh token)
    Backend->>-Frontend: generate and return refresh token, access token
    Frontend->>+Backend: /items (with new access token)
    Backend->>-Frontend: list of items (success)
```

### refresh token이 만료된 케이스

![image](https://github.com/codeleeks/blog/assets/166087781/8fce7fcb-ad9b-4ad7-9275-dba5a87b28a6)


access token이 만료된 케이스와 동일한 플로우로 진행되는데, refresh token도 만료되었기 때문에 로그인을 요구해야 한다.

`/refresh` API는 refresh token이 만료되었음을 확인하고, 오류 응답을 보낸다.

응답을 받은 프론트엔드는 로그인 페이지로 이동한다.

```
sequenceDiagram
    Frontend->>+Backend: /items (the request required the authentication)
    Backend->>-Frontend: return UNAUTHORIZED response
    Frontend->>+Backend: /refresh (also sending refresh token)
    Backend->>-Frontend: return UNAUTHORIZED response
    Frontend->>+Frontend: navigate to /signin page
```


### 프론트엔드 코드

auth 정보를 관리하는 것이 핵심이다.

상태 관리는 `context`로, 서버와 통신은 `fetch`로, 브라우저 저장소는 `cookie`를 사용했다.

#### 쿠키 관리

```typescript
// Cookies
const REFRESH_TOKEN_KEY = 'refreshToken'
const ACCESS_TOKEN_KEY = 'accessToken'

function numberToDate(min: number) {
  const dt = new Date()
  dt.setSeconds(dt.getSeconds() + min)
  return dt
}

function storeAuth(refreshToken: string, accessToken: string) {
  setCookie(REFRESH_TOKEN_KEY, refreshToken, {
    path: '/',
    expires: numberToDate(10),
  })
  setCookie(ACCESS_TOKEN_KEY, accessToken, {
    path: '/',
    expires: numberToDate(3),
  })
}

function removeAuth() {
  removeCookie(REFRESH_TOKEN_KEY)
  removeCookie(ACCESS_TOKEN_KEY)
}

export function getRefreshToken() {
  return getCookie(REFRESH_TOKEN_KEY)
}

export function getAccessToken() {
  return getCookie(ACCESS_TOKEN_KEY)
}
```

#### Fetch

```typescript
const url = 'http://localhost:8080'
async function fetchLogin(email: string, password: string) {
  try {
    const resp = await fetch(`${url}/login`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        email,
        password,
      }),
    })

    if (!resp.ok) {
      return null
    }

    return {
      refreshToken: resp.headers.get('x-refresh-token'),
      accessToken: resp.headers.get('x-access-token'),
    }
  } catch (e) {
    console.error(e)
  }
}

async function fetchLogout() {
  const resp = await fetch(`${url}/logout`, {
    method: 'POST',
    headers: {
      'x-refresh-token': getRefreshToken(),
      'x-access-token': getAccessToken(),
    },
  })
  if (!resp.ok) {
    return null
  }

  return true
}


export async function fetchWithAuth(
  sub: string,
  options?: any,
  step: number = 0
) {
  const fetchOption = { ...options }
  fetchOption.headers = {
    ...fetchOption.headers,
    'x-access-token': getAccessToken(),
  }

  const resp = await fetch(`${url}/${sub}`, fetchOption)
  if (!resp.ok) {
    if (step < 1) {
      const token = await refreshAuth()
      if (token && token.refreshToken && token.accessToken) {
        storeAuth(token.refreshToken, token.accessToken)
        return await fetchWithAuth(sub, options, step + 1)
      } else {
        return null
      }
    } else {
      return null
    }
  }

  return await resp.json()
}

export async function refreshAuth() {
  const resp = await fetch(`${url}/refresh`, {
    method: 'POST',
    headers: {
      'x-refresh-token': getRefreshToken(),
    },
  })

  if (!resp.ok) {
    return null
  }

  return {
    refreshToken: resp.headers.get('x-refresh-token'),
    accessToken: resp.headers.get('x-access-token'),
  }
}
```

auth가 필요한 페이지에서는 loader 함수에서 `fetchWithAuth`를 사용하여 서버에서 데이터를 가져와야 한다.

`fetchWithAuth` 함수는 retry 기능을 갖고 있다.

실패시 `fetchRefresh` 함수를 호출하여 토큰 재발급을 시도한다.

#### Context

```typescript
function isAuthenticatedOnReload() {
  const refreshToken = getCookie(REFRESH_TOKEN_KEY)
  return refreshToken === '' ? undefined : true
}

const authContext = createContext({
  isAuthenticated: isAuthenticatedOnReload(),
  setIsAuth: (auth: boolean | undefined) => {},
  login: (email: string, password: string) => {},
  logout: () => {},
})

type AuthContextProviderProps = {
  children: ReactNode
}

export const AuthContextProvider = ({ children }: AuthContextProviderProps) => {
  const [isAuth, setIsAuth] = useState(isAuthenticatedOnReload())

  const login = async (email: string, password: string) => {
    console.debug('login')
    const token = await fetchLogin(email, password)
    if (token && token.refreshToken && token.accessToken) {
      setIsAuth(true)
      storeAuth(token.refreshToken, token.accessToken)
    } else {
      setIsAuth(false)
    }
  }

  const logout = async () => {
    console.debug('logout')
    await fetchLogout()
    setIsAuth(undefined)
    removeAuth()
  }

  const value = {
    isAuthenticated: isAuth,
    setIsAuth,
    login,
    logout,
  }
  return <authContext.Provider value={value}>{children}</authContext.Provider>
}

export function useAuthContext() {
  return useContext(authContext)
}

export function AuthNeccessaryPage({ children }: { children: ReactNode }) {
  const authCtx = useAuthContext()
  const isAuthenticated = authCtx.isAuthenticated && isAuthenticatedOnReload()
  const setIsAuth = authCtx.setIsAuth
  const navigate = useNavigate()
  useEffect(() => {
    console.debug('refreshed! - ', isAuthenticated)
    if (!isAuthenticated) {
      setIsAuth(isAuthenticated)
      navigate('/signin')
    }
  }, [isAuthenticated, setIsAuth])
  return <>{children}</>
}
```


context는 `isAuthenticated` 상태를 관리한다.
 
`undefined`는 로그인하지 않은 상태, `true`는 로그인한 상태, `false`는 로그인 실패한 상태이다.

`AuthNeccessaryPage`는 authentication이 필요한 페이지 컴포넌트를 감싸서 현재 로그인 상태가 아니면 로그인 페이지로 이동한다.

루트 페이지에서는 `AuthNeccessaryPage`를 활용하고 있다.

```typescript
import { NavLink, Outlet, useLocation } from 'react-router-dom'
import { AuthNeccessaryPage, useAuthContext } from '../store/auth'

const noAuthPage = ["/"]

const RootPage = () => {
  const authCtx = useAuthContext()
  const { pathname } = useLocation()

  const onSignOut = () => {
    authCtx.logout()
  }

  const isAuthPage = !noAuthPage.includes(pathname)

  return (
    <>
      <nav>
        <NavLink to=''>Home</NavLink>
        <NavLink to='items'>Items</NavLink>
        {!authCtx.isAuthenticated && <NavLink to='signin'>SignIn</NavLink>}
        {authCtx.isAuthenticated && (
          <button onClick={onSignOut}>SignOut</button>
        )}
      </nav>

      {isAuthPage && (
        <AuthNeccessaryPage key={pathname}>
          <Outlet />
        </AuthNeccessaryPage>
      )}
      {!isAuthPage && <Outlet />}
    </>
  )
}

export default RootPage
```

#### 전체 코드 보기

[전체 코드 보기](https://github.com/codeleeks/tokenAuthenticationFrontend)

### 백엔드 코드

JWT 토큰 발급하고, request header에서 토큰 조회하고 유효성 검증하는 로직이 핵심이다.


#### JWT 토큰 발급

JWT 토큰 발급은 `jsonwebtoken` 패키지를 사용한다.

```gradle
	implementation 'io.jsonwebtoken:jjwt:0.9.1'
	implementation 'com.sun.xml.bind:jaxb-impl:4.0.1'
	implementation 'com.sun.xml.bind:jaxb-core:4.0.1'
	implementation 'javax.xml.bind:jaxb-api:2.4.0-b180830.0359'
```

```java
package com.workspace.tokenAuthenticationBackend.web.jwt;

import io.jsonwebtoken.Header;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;

import java.util.Date;

public class JWTGenerator {

    public String accessToken(String email) {
        Date now = new Date();

        return Jwts.builder()
                .setHeaderParam(Header.TYPE, Header.JWT_TYPE) // (1)
                .setIssuer("fresh") // (2)
                .setIssuedAt(now) // (3)
                .setExpiration(new Date(now.getTime() + JWTConstant.accessDuration)) // (4)
                .claim("email", email)
                .signWith(SignatureAlgorithm.HS256, "secret") // (6)
                .compact();
    }

    public String refreshToken(String email) {
        Date now = new Date();
        return Jwts.builder()
                .setHeaderParam(Header.TYPE, Header.JWT_TYPE) // (1)
                .setIssuer("fresh") // (2)
                .setIssuedAt(now) // (3)
                .setExpiration(new Date(now.getTime() + JWTConstant.refreshDuration)) // (4)
                .claim("email", email)
                .signWith(SignatureAlgorithm.HS256, "secret") // (6)
                .compact();
    }
}

```

`iss`, `exp`를 설정하고, 커스텀 클레임으로 email을 추가했다.

refresh token과 access token의 차이는 `exp`이다.


#### 로그인 체킹 필터

authentication이 필요한 API는 request header에 access token이 있어야 한다.

filter 영역에서 이를 확인한다.

`LoginCheckFilter.java`
```java
package com.workspace.tokenAuthenticationBackend.web.filter;

import com.workspace.tokenAuthenticationBackend.web.jwt.JWTTokenProvider;
import jakarta.servlet.*;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.web.util.ContentCachingResponseWrapper;

import java.io.IOException;
import java.util.Objects;

@Slf4j
@RequiredArgsConstructor
public class LoginCheckFilter implements Filter {
    private final JWTTokenProvider jwtTokenProvider;

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        HttpServletResponse httpResponse = (HttpServletResponse) response;

        if (Objects.equals(httpRequest.getMethod(), "OPTIONS")) {
            log.info("OPTION packet accepted");
            chain.doFilter(request, response);
            return;
        }
        String accessTokenHeader = httpRequest.getHeader("x-access-token");

        boolean hasTokenExpired = jwtTokenProvider.hasTokenExpired(accessTokenHeader);
        if (hasTokenExpired) {
            ContentCachingResponseWrapper wrapperResponse = new ContentCachingResponseWrapper(httpResponse);
            chain.doFilter(request, wrapperResponse);
            wrapperResponse.setStatus(HttpStatus.UNAUTHORIZED.value());
            return;
        }


//            String refreshTokenHeader = httpRequest.getHeader("x-refresh-token");
//            try {
//                Claims claims = jwtTokenProvider.parseJwtToken(refreshTokenHeader);
//                String email = (String) claims.get("email");
//                ContentCachingResponseWrapper wrapperResponse = new ContentCachingResponseWrapper(httpResponse);
//                chain.doFilter(request, wrapperResponse);
//                wrapperResponse.setHeader("x-access-token", new JWTGenerator().accessToken(email));
//                wrapperResponse.setHeader("x-refresh-token", new JWTGenerator().refreshToken(email));
//                wrapperResponse.copyBodyToResponse();
//                return;
//            } catch (ExpiredJwtException innerE) {
//                log.info("로그인 다시 하세요~");
//                ContentCachingResponseWrapper wrapperResponse = new ContentCachingResponseWrapper(httpResponse);
//                chain.doFilter(request, wrapperResponse);
//                wrapperResponse.setStatus(HttpStatus.UNAUTHORIZED.value());
//                return;
//            }


        chain.doFilter(request, response);

//        https://medium.com/sjk5766/spring-filter%EC%97%90%EC%84%9C-response-%EC%88%98%EC%A0%95%ED%95%98%EA%B8%B0-7de6da9836f5
    }
}

```

`JWTTokenProvider.java`
```java
package com.workspace.tokenAuthenticationBackend.web.jwt;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.Jwts;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

@Slf4j
@Component
public class JWTTokenProvider {
    public Claims parseJwtToken(String tokenHeader) {
        validationAuthorizationHeader(tokenHeader); // (1)
        log.info("token {}", tokenHeader);
        return Jwts.parser()
                .setSigningKey("secret") // (3)
                .parseClaimsJws(tokenHeader) // (4)
                .getBody();
    }

    public boolean hasTokenExpired(String tokenHeader) {
        try {
            parseJwtToken(tokenHeader);
            return false;
        } catch (ExpiredJwtException | IllegalArgumentException e) {
            log.error("expired! " + e.getMessage());
        }
        return true;
    }

    private void validationAuthorizationHeader(String header) {
        if (header == null || header.isEmpty()) {
            throw new IllegalArgumentException();
        }
    }
}

```

`JWTTokenProvider`의 `hasTokenExpired` 메서드로 토큰의 유효성 여부를 확인한다.

토큰 파싱 과정에서 `ExpiredJwtException`이 발생하면 만료된 토큰이다.

#### 전체 코드 보기

[전체 코드 보기](https://github.com/codeleeks/tokenAuthenticationBackend)
