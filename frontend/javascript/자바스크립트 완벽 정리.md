---
summary: 자바스크립트를 처음부터 끝까지 정리합니다.
date: 2024-05-20
title-image: 'https://raw.githubusercontent.com/codeleeks/blog/codeleeks-images/javascript/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%20%EC%99%84%EB%B2%BD%20%EC%A0%95%EB%A6%AC/title.png'
---

## 자바스크립트 파싱 & 실행

![image](https://github.com/user-attachments/assets/92101ef2-252c-49be-9d17-1086a7137ea0)

출처: [개발은 재밌어서 하는거야](https://yoon-dumbo.tistory.com/entry/V8%EC%9D%80-JS%EB%A5%BC-%EC%BB%B4%ED%8C%8C%EC%9D%BC-%ED%95%A0-%EB%95%8C-Interpreter-%EC%9D%98-%EB%8A%90%EB%A6%B0-%EC%8B%A4%ED%96%89-%EC%86%8D%EB%8F%84%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B0%9C%EC%84%A0-%ED%96%88%EC%9D%84%EA%B9%8C?pidx=2)

chrome 기준으로 정리하면 `V8`이라는 자바스크립트 엔진 내에는 인터프리터와 여러 컴파일러가 존재한다.
파서가 자바스크립트 코드에서 AST를 생성하면 인터프리터(`ignition`)가 AST를 바이트코드로 바꾸고, 실행한다.

그런데 V8이 코드 실행을 모니터링하면서 최적화할 일부 코드를 찾았다면, '최적화 컴파일러'(`TurboFan`, just in time compiler)를 통해 최적화가 적용된 머신코드로 변환한다.
최적화 실패시 다시 원래 바이트 코드로 복구한다.
머신코드로 바꾸어 저장하는 작업은 바이트코드보다 메모리가 많이 소요된다.
그래서 메모리 소모라는 비용보다 처리 속도 향상이라는 이점이 더 큰 코드만 머신코드로 변경하는 것이다. (동일한 로직이 자주 실행되는 코드가 이에 해당한다.)

[내용은 여기서 참고했습니다.](https://woo1031.vercel.app/article/v8-javascript-engine%EC%97%90%EC%84%9C-bytecode%EC%99%80-machine-code%EB%A5%BC-%ED%95%A8%EA%BB%98-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0)

<MessageBox title='just in compiler' level='info'>
  스크립트를 읽고, 머신 코드로 변환한 뒤 바로 실행하는 컴파일러.
</MessageBox>

## primitive와 reference 값

| `primitive`                                                               | `reference`                                                       |
| ------------------------------------------------------------------------- | ----------------------------------------------------------------- |
| Strings, Numbers, Booleans, null, undefined, Symbol                       | All other objects                                                 |
| 메모리 비용이 저렴                                                        | 메모리 비용이 비쌈                                                |
| 복사할 때 원본 변수를 바꿔도 복사된 변수값이 변하지 않음 (값 자체를 복사) | 복사할 때 원본 변수를 바꿔도 복사된 변수값이 변함 (포인터를 복사) |

<MessageBox title='primitive value가 객체처럼 사용될 수 있는 이유' level='info'>
  `primitive`도 객체처럼 `dot` 연산자를 사용하여 필드에 접근할 수 있는데,
  이는 `dot` 연산자 사용시 동적으로 `object`으로 변환되기 때문.
  
  그러나, dot 연산자를 사용한다고 해서 `reference`로 바뀌는 것은 아님.
</MessageBox>

## bind()

javascript의 `bind()` 함수는 함수 호출 전에 넘길 파라미터를 정해줄 수 있다.

### 예제

```js
const showResult = (message, result) => {
  console.log(message + ' ' + result)
}

const combine = function (resultHandler, operation, ...numbers) {
  let result = 0
  if (operation === 'Add') {
    for (const number of numbers) {
      result += number
    }
  } else if (operation === 'Subtract') {
    for (const number of numbers) {
      result -= number
    }
  }

  // bind()를 통해 The result of adding those numbers are:가 첫 번째 파라미터에 할당되었기 때문에, result는 두 번째 파라미터에 할당됨.
  resultHandler(result)
}

combine(
  showResult.bind('The result of adding those numbers are:'),
  'Add',
  1,
  5,
  -1,
  2
)
combine(
  showResult.bind('The result of subtracting those numbers are:'),
  'Subtract',
  1,
  5,
  -1,
  2
)

// 결과
// The result of adding those numbers are: 7
// The result of subtracting those numbers are: -7
```

## this

자바스크립트는 인터프리팅된다.
코드 한 줄 한 줄마다 실행시 참조하는 실행컨텍스트(execution context)가 있다.

자바스크립트에서 this는 현재 코드의 실행컨텍스트이다.

그래서 this는 this가 사용되는 코드가 어느 맥락에서 사용되는지가 중요하다. (dynamic scoping)

아래의 코드에서 this는 객체가 호출하는 메서드에서 실행되느냐, 객체의 메서드를 뽑아 생성한 새 함수변수에서 실행되느냐에 따라 해석이 달라진다.

```js
const obj = {
  info: { title: 'title!' },
  getFormattedTitle() {
    return this.info.title.toUpperCase()
  },
}

const { getFormattedTitle } = obj
getFormattedTitle() // 결과: undefined 에러 발생
obj.getFormattedTitle() // 결과: TITLE!
```

새 함수변수인 `getFormattedTitle()`에서 사용되는 `this`를 `console`로 찍어보면 윈도우 객체가 나온다.
`getFormattedTitle`를 호출하면 내부에 `this`가 윈도우 객체로 해석되기 때문에 `info` 필드에 접근할 수 없어 undefined 에러가 발생한다.

```bash
Window {window: Window, self: Window, document: document, name: '', location: Location, …}
```

이는 객체의 메서드가 실은 숨겨진 첫 번째 인자가 있기 때문이다.
객체의 모든 메서드는 첫 번째 인자로 this 포인터를 받는다. 

`obj.getFormattedTitle()`의 경우 인터프리터는 `getFormattedTitle(obj)`로 변환하여 실행한다.
그런데, `getFormattedTitle()`의 경우 인터프리터는 `getFormattedTitle(전역객체 this)`로 변환하여 실행한다.
브라우저에서 전역객체 this는 윈도우이므로, `getFormattedTitle()`에서의 this는 윈도우 객체를 참조하고 있었던 것이다.

`getFormattedTitle()`에서 사용되는 this를 전역 객체가 아닌 `obj`의 this로 넣어주려면 `bind()`를 쓰면 된다.
`bind()`는 함수 호출 전에 파라미터를 미리 넣어주는 개념이라고 했다.
그래서 `bind`를 사용해 `getFormattedTitle`의 숨겨진 첫 번째 파라미터를 `obj`으로 미리 넣어둘 수 있다.

```js
let { getFormattedTitle } = obj
const obj2 = { ...obj }
getFormattedTitle = getFormattedTitle.bind(obj2)
getFormattedTitle() // 결과: TITLE!
```

아니면 `call`를 사용할 수도 있다. `bind`는 새로운 함수를 반환하고, `call`은 바로 실행한다.

```js
let { getFormattedTitle } = obj
const obj2 = { ...obj }
getFormattedTitle.call(obj2) // 결과: TITLE!
```

### addEventListener의 callback 함수가 동작하는 방식

```js
const clickHandler = function () {
  console.log('clicked! - ', this)
}

const btnEl = document.querySelector('button')
btnEl.addEventListener('click', clickHandler)
```

콜백 함수의 this의 주인은 무엇일까?

브라우저는 콜백함수의 this를 이벤트를 발행한 DOM 객체에 `bind`한다.

따라서 `clickHandler`의 `this` 는 `btnEl`이다.

### 화살표 함수

화살표 함수가 도입된 배경 중 하나는 dynamic scoping이 주는 혼란이다.

화살표 함수는 lexical scoping으로 동작한다.
화살표 함수의 this는 어디서 실행되느냐가 중요한 것이 아니라 코드적으로 어디서 정의되었느냐가 중요하다.

```js
const members = {
  teamName: 'Blue Rockets',
  people: ['MAX', 'Manuel'],
  getTeamMembers() {
    this.people.forEach((p) => {
      console.log(this) //결과: members 객체
      console.log(p + ' - ' + this.teamName) //결과: MAX - Blue Rockets, Manuel - Blue Rockets
    })
  },
  // getTeamMembers() {
  //   this.people.forEach(function(p) {
  //     console.log(this) //결과: window 객체
  //     console.log(p + ' - ' + this.teamName) //결과: MAX - undefined, Manuel - undefined
  //   })
  // },
}
```

react에서도 bind 패턴 대신 화살표 함수를 주로 사용해왔다.

```js

class Component {

  handleEvent(e) {
    console.log(e.target.value)
  }

  render() {
    return <div onClick={e => this.handleEvent(e)}></div>
  }
}
```

### 정리

`this`가 사용되는 케이스에 따라 그 의미를 아래 표로 정리한다.

| `this`가 사용되는 곳                      | 의미                                                             | 엄격 모드 적용시                                                 |
| ----------------------------------------- | ---------------------------------------------------------------- | ---------------------------------------------------------------- |
| 전역 컨텍스트                             | `window`                                                         | `window`                                                         |
| 전역 컨텍스트의 function 키워드의 함수 안 | `window`                                                         | `undefined`                                                      |
| 화살표 함수 안                            | 함수 바깥 객체 컨텍스트. 전역 컨텍스트에서 호출되었으면 `window` | 함수 바깥 객체 컨텍스트. 전역 컨텍스트에서 호출되었으면 `window` |
| 메서드로서의 function 키워드의 함수 안    | 객체 컨텍스트                                                    | 객체 컨텍스트                                                    |
| 메서드로서의 화살표 함수 안               | `window`                                                         | `window`                                                         |
| 메서드 안에서 정의된 화살표 함수 안               | 메서드를 정의한 객체                                                         | 메서드를 정의한 객체                                                         |

결국 this를 고민하지 않기 위해선, 대부분의 경우에 화살표 함수를 쓰자(lexical scoping이기 때문에).
한 가지 중요한 예외는 객체의 메서드를 정의할 때 화살표 함수에서 this는 전역 객체이기 때문에 function 키워드를 써야 한다는 점이다.

## prototype

> prototype은 fallback class이다. 객체 스스로가 정의하지 않은 프로퍼티나 메서드를 요구할 때 `__proto__` 프로퍼티에 들어가 찾아본다.
> `__proto__`에도 없으면 그 안의 또 `__proto__`에 들어가 찾아보고, 이런 식으로 `__proto__`가 null에 도달할 때까지 찾아본다.

<MessageBox title='__proto__가 null?' level='info'>
  Object의 `__proto__` 는 anonymous이고, anonymous의 `__proto__`는 Object이며, Object의 `__proto__`는 null이다.
  
  여기서부턴 내 추측인데, 생섬자 함수도 결국은 객체이기 때문에 `__proto__`가 존재하고, default로는 Object 프로토타입이 들어가는데 이 때, anonymous의 경우에는 Object의 프로토타입이기 때문에 순환 구조가 발생한다. 
  이를 막기 위해 예외적으로 anonymous의 Object는 다른 `__proto__`를 갖는 것 같다.
</MessageBox>

`.prototype`은 `__proto__`와는 다르다.

| `__proto__`                                     | `.prototype`                     |
| ----------------------------------------------- | -------------------------------- |
| 객체를 만든 생성자 함수에서 정의한 프로토타입   | 생성될 객체의 프로토타입을 정의. |
| 모든 자바스크립트 객체에 존재(생성자 함수 포함) | 생성자 함수에만 존재             |

```js
function User() {
  ...
}
User.prototype = {age: 10}

const user1 = new User()
console.log(user1.__proto__ === user1.prototype) //결과: true
console.log(user1.__proto__ === User.prototype) //결과: true
console.log(user1.__proto__ === User.__proto__) //결과: false
```

### 메서드 형태가 다르면 동작도 달라진다?

자바스크립트의 특이한 점이라고 한다면, 같은 의미임에도 표현하는 방식에 따라 동작이 미묘하게 달라진다는 것이다.

메서드를 작성하는 방법은 세 가지가 있다.

`Method shorthand`

```js
class Person {
  greet() {}
}
```

`Property Function`

```js
class Person {
  greet = function () {}
}
```

`Property Arrow Function`

```js
class Person {
  greet = () => {}
}
```

각 방식으로 함수를 정의한 뒤 객체를 만들고 console로 내부를 들여다보면 미묘하게 다르다는 것을 알 수 있다.

| Method Shorthand                                        | Property Function                                      | Property Arrow Function                              |
| ------------------------------------------------------- | ------------------------------------------------------ | ---------------------------------------------------- |
| prototype에 정의됨                                      | 프로퍼티에 정의됨                                      | 프로퍼티에 정의됨                                    |
| 객체를 여러 개 만들면 메모리 절약 등의 성능 이점이 있음 | 모든 객체마다 새로 생성되기 때문에 성능 이점은 없음    | 모든 객체마다 새로 생성되기 때문에 성능 이점은 없음  |
| event listener에 등록할 때 this는 DOM 객체가 되어 버림  | event listener에 등록할 때 this는 DOM 객체가 되어 버림 | event listener에 등록할 때 this는 객체 자신으로 유지 |

### 동적으로 프로퍼티와 프로토타입을 주입하는 방법

자바스크립트에서는 이미 생성된 객체에 프로토타입을 주입할 수 있다.

- `Object.defineProperty()`: 객체에 프로퍼티 주입.
- `Object.create()`: 객체 생성시에 프로토타입을 정의

```js
const student = Object.create(
  {
    printProgress: function () {
      console.log(this.progress)
    },
  },
  {
    name: 'hi',
  }
)

Object.defineProperty(student, 'progress', 0.8)
```

## 고급 함수

### Side Effects

`side effects`란 함수 내에서 외부에 영향을 끼칠 무언가를 하는 행위를 말한다.

HTTP 요청 보내거나, 전역 변수를 변경하는 등이다.

### 클로저

> 자바스크립트의 모든 함수는 클로저다.

클로저란 내부에서 사용하고 있는 모든 변수를 저장하는 함수이다.

함수 밖에서 정의된 변수더라도 내부에서 사용되고 있다면 저장한다.

## 비동기 - Promise & 콜백

비동기 코드의 가독성을 높이기 위해, `Promise` 객체를 지원한다.

> 비동기 코드가 nested되면 콜백 지옥(에너지파~!)이 발생한다.

`Promise` 생성자로 오래 걸리는 API를 래핑하고,

성공, 실패에 따라 `resolve`, `reject`를 호출하는 콜백을 등록한다.

`Promise`가 제공하는 `then`, `catch` 메서드가 콜백 결과를 처리하는 비동기 로직을 작성할 수 있게 제공한다.

```js
function getPosition() {
  const promise = new Promise((resolve, reject) => {
    navigator.geolocation.getCurrentPosition(
      (success) => {
        resolve(sucess)
      },
      (error) => {
        reject(error)
      }
    )
  })

  return promise
}

getPosition()
  .then((posData) => {
    console.log(posData)
  })
  .catch((err) => {
    console.error(err)
  })
```

### Promise의 상태

| `PENDING`                       | `RESOLVED`           | `REJECTED`        | `SETTLED`          |
| ------------------------------- | -------------------- | ----------------- | ------------------ |
| 프로미스가 작동 중              | 프로미스가 resolve됨 | 프로미스가 거부됨 | 프로미스 체인 종료 |
| 어떤 함수도 호출하지 않음(멈춤) | `then()` 호출        | `catch()` 호출    | `finally()` 호출   |

> `catch`나 `then` 블록 다음에 또 다른 `then` 블록이 있으면 프로미스가 `PENDING` 모드로 다시 들어간다.
> `then`과 `catch`는 항상 새로운 프로미스를 반환한다.
> `then` 내부에서 return하면 `resolve`로 처리.

<MessageBox title='`reject`가 발생하면 가장 가까운 `catch`를 찾을 때까지 이후 `then` 로직을 스킵한다.' level='info'>
  ```js
    getPosition()
      .then((posData) => {
        console.log(posData)
      })
      //some other async logic, which will be skipped if first promise throw an error by calling reject()
      .then()
      .then()
      .catch((err) => {
        console.error(err)
      })
  ```

그래서 catch는 promise 체인의 가장 마지막에 두는 것이 좋다.

</MessageBox>

### async/await와 raw promise

`async` 함수 내의 `await`를 걸지 않은 로직 또한 내부적으로 `then`으로 묶어버린다.

비동기 로직 전에 실행해야 할 로직이 함수 내에 있다면, raw promise 방식이 낫다.

```js
async function getGeoPosition() {
  try {
    const position = await getPosition()
  } catch (e) {
    console.error(e)
    return
  }

  // async/await 패턴에서는 위쪽 비동기 로직이 모두 완료된 후에야 호출된다.
  doSomethingImmediately()
}
```

### 여러 프로미스 처리하기

| `Promise.race()`                                          | `Promise.all()`                                                                                                                             | `promise.allSettled()`                                       |
| --------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------ |
| `Promise`의 `array`를 파라미터로 받는다.                  | `Promise`의 `array`를 파라미터로 받는다.                                                                                                    | `Promise`의 `array`를 파라미터로 받는다.                     |
| 가장 빨리 종료된(resolve, reject 상관없이) `promise` 반환 | 모든 `promise`가 **resolve** 될 때까지 기다린 뒤 `promise` 배열 반환. 하나라도 `reject`되면 `PENDING` 상태인 `promise`도 취소하고 반환한다. | 모든 `promise`가 종료될 때까지 기다린 뒤 `promise` 배열 반환 |


## String 다루기

- `lastIndexOf`
- `endsWith`
- `substring`

```javascript
const path = '/javascript/libraries/gsap summary.md'
const getFileName = (path) => {
  if (path.endsWith('.md') {
    return path
  }

  const lastIndex = path.lastIndexOf('/')
  return path.substring(lastIndex + 1)
}

//결과: gsam summary.md
getFileName(path)
```

## 객체 다루기

- 객체 안에 필드가 있는지 없는지 확인하는 방법

```javascript
const obj = {}
const field = 'someField'

if (field in obj) {
  // someField가 obj 객체에 필드로 있는 경우
}

if (obj[field] !== undefined) {
  // someField가 obj 객체에 필드로 있는 경우
}
```

## 스프레드 연산

- 배열은 스프레드 연산시 주의해야 한다.

```javascript
const obj = {}
const category = 'category'

//성공
if (obj[category] === undefined) {
  obj[category] = []
} else {
  obj[category].push(post)
}

//실패
obj[category] = [...obj[category], post]
```


## Array의 프로토타입(메서드)

- 원본 배열 영향 O: `splice`, `sort`
- 원본 배열 영향 X: `slice`, `map`, `filter`, `reduce`

```javascript
// const sp = arr.splice(3, 1)
// console.log(sp) //4
// console.log(arr) //1,2,3,5

// const s = arr.sort((a,b)=>b-a)
// console.log(s) //5, 4, 3, 2, 1
// console.log(arr) //5, 4, 3, 2, 1

// const m = arr.map(i => {
//   return "hello" + i
// })

// m.shift()
// console.log(arr) //1,2,3,4,5


// const f = arr.filter(i => i % 2 === 0)
// f.shift()
// console.log(arr)


// const s = arr.slice(3, 4)
// s.unshift(10)
// console.log(s) //10, 4, 5
// console.log(arr) //1,2,3,4,5
```


- `splice(시작 인덱스, 삭제할 요소 갯수)`
- `slice(시작 인덱스, 끝 인덱스(exclusive))`


### 배열에 요소 삽입/삭제하기

- 앞에 삽입: `unshift()`
- 뒤에 삽입: `push()`
- 맨 앞 요소 삭제: `shift()`
- 맨 뒤 요소 삭제: `pop()`

```javascript
arr.pop()
console.log(arr)

arr.push(10)
console.log(arr)

arr.shift()
console.log(arr)

arr.unshift(1)
console.log(arr)
```
