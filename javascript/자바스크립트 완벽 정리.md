---
summary: 자바스크립트를 처음부터 끝까지 정리합니다.
date: 2024-05-20
title-image: 'https://raw.githubusercontent.com/codeleeks/blog/codeleeks-images/javascript/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%20%EC%99%84%EB%B2%BD%20%EC%A0%95%EB%A6%AC/title.png'
---

## 자바스크립트 파싱 & 실행

chrome 기준으로 정리하면,

`V8`이라는 자바스크립트 엔진 내에는 인터프리터와 여러 컴파일러가 존재한다.

> 자바스크립트 코드 ➡️ AST ➡️ 바이트코드 ➡️ 실행

`V8` 내 컴파일러(`TurboFan` 아님)가 자바스크립트 코드에서 AST를 생성하면

인터프리터(`ignition`)가 AST를 바이트코드로 바꾸고, 실행한다.

그런데,

V8이 코드 실행을 모니터링하면서 최적화할 일부 코드를 찾았다면,

'최적화 컴파일러'(`TurboFan`, just in time compiler)를 통해 최적화가 적용된 머신코드로 변환한다.

최적화 실패시 다시 원래 바이트 코드로 복구한다.

[내용은 여기서 참고했습니다.](https://woo1031.vercel.app/article/v8-javascript-engine%EC%97%90%EC%84%9C-bytecode%EC%99%80-machine-code%EB%A5%BC-%ED%95%A8%EA%BB%98-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0)

<MessageBox title='just in compiler' level='info'>
  스크립트를 읽고, 머신 코드로 변환한 뒤 바로 실행하는 컴파일러.
</MessageBox>

## primitive와 reference 값

| `primitive`                                                               | `reference`                                                       |
| ------------------------------------------------------------------------- | ----------------------------------------------------------------- |
| Strings, Numbers, Booleans, null, undefined, Symbol                       | All other objects                                                 |
| 메모리 비용이 저렴                                                        | 메모리 비용이 비쌈                                                |
| 복사할 때 원본 변수를 바꿔도 복사된 변수값이 변하지 않음 (값 자체를 복사) | 복사할 때 원본 변수를 바꿔도 복사된 변수값이 변함 (포인터를 복사) |

<MessageBox title='primitive value가 객체처럼 사용될 수 있는 이유' level='info'>
  `primitive`도 객체처럼 `dot` 연산자를 사용하여 필드에 접근할 수 있는데,
  이는 `dot` 연산자 사용시 동적으로 `object`으로 변환되기 때문.
  
  그러나, dot 연산자를 사용한다고 해서 `reference`로 바뀌는 것은 아님.
</MessageBox>

## bind()

javascript의 `bind()` 함수는 함수 호출 전에 넘길 파라미터를 정해줄 수 있다.

### 예제

```js
const showResult = (message, result) => {
  console.log(message + ' ' + result)
}

const combine = function (resultHandler, operation, ...numbers) {
  let result = 0
  if (operation === 'Add') {
    for (const number of numbers) {
      result += number
    }
  } else if (operation === 'Subtract') {
    for (const number of numbers) {
      result -= number
    }
  }

  // bind()를 통해 The result of adding those numbers are:가 첫 번째 파라미터에 할당되었기 때문에, result는 두 번째 파라미터에 할당됨.
  resultHandler(result)
}

combine(
  showResult.bind('The result of adding those numbers are:'),
  'Add',
  1,
  5,
  -1,
  2
)
combine(
  showResult.bind('The result of subtracting those numbers are:'),
  'Subtract',
  1,
  5,
  -1,
  2
)

// 결과
// The result of adding those numbers are: 7
// The result of subtracting those numbers are: -7
```

## this

```js
const obj = {
  info: { title: 'title!' },
  getFormattedTitle() {
    return this.info.title.toUpperCase()
  },
}

const { getFormattedTitle } = obj
getFormattedTitle() // 결과: undefined 에러 발생
obj.getFormattedTitle() // 결과: TITLE!
```

`this`를 `console`로 찍어보면 윈도우 객체가 나온다.

```bash
Window {window: Window, self: Window, document: document, name: '', location: Location, …}
```

`getFormattedTitle`를 호출하면 내부에 `this`가 윈도우 객체로 해석되기 때문에 `info` 필드에 접근할 수 없어 undefined 에러가 발생한다.

이럴 때 `bind`를 사용해 `getFormattedTitle`의 주인을 찾아준다.

```js
let { getFormattedTitle } = obj
const obj2 = { ...obj }
getFormattedTitle = getFormattedTitle.bind(obj2)
getFormattedTitle() // 결과: TITLE!
```

아니면 `call`를 사용할 수도 있다. `bind`는 새로운 함수를 반환하고, `call`은 바로 실행한다.

```js
let { getFormattedTitle } = obj
const obj2 = { ...obj }
getFormattedTitle.call(obj2) // 결과: TITLE!
```

### addEventListener의 callback 함수가 동작하는 방식

```js
const clickHandler = function () {
  console.log('clicked! - ', this)
}

const btnEl = document.querySelector('button')
btnEl.addEventListener('click', clickHandler)
```

콜백 함수의 this의 주인은 무엇일까?

브라우저는 콜백함수의 this를 이벤트를 발행한 DOM 객체에 `bind`한다.

따라서 `clickHandler`의 `this` 는 `btnEl`이다.

<MessageBox title='화살표 함수는 function 키워드의 함수와 다르다.' level='warning'>
  화살표 함수 안의 `this`는 함수 밖으로 나가서 정의된다고 보면 된다.
  그래서 function 키워드의 함수 안에서 사용되는 `this`는 `use strict`를 통해 window 객체가 아니라 undefined로 변경할 수 있지만,
  화살표 함수 안의 `this`는 변경할 수 없다.

화살표 함수의 `this`가 유용한 케이스도 있다.

```js
const members = {
  teamName: 'Blue Rockets',
  people: ['MAX', 'Manuel'],
  getTeamMembers() {
    this.people.forEach((p) => {
      console.log(this) //결과: members 객체
      console.log(p + ' - ' + this.teamName) //결과: MAX - Blue Rockets, Manuel - Blue Rockets
    })
  },
  // getTeamMembers() {
  //   this.people.forEach(function(p) {
  //     console.log(this) //결과: window 객체
  //     console.log(p + ' - ' + this.teamName) //결과: MAX - undefined, Manuel - undefined
  //   })
  // },
}
```

</MessageBox>

### 정리

`this`가 사용되는 케이스에 따라 그 의미를 아래 표로 정리한다.

| `this`가 사용되는 곳                      | 의미                                                             | 엄격 모드 적용시                                                 |
| ----------------------------------------- | ---------------------------------------------------------------- | ---------------------------------------------------------------- |
| 전역 컨텍스트                             | `window`                                                         | `window`                                                         |
| 전역 컨텍스트의 function 키워드의 함수 안 | `window`                                                         | `undefined`                                                      |
| 화살표 함수 안                            | 함수 바깥 객체 컨텍스트. 전역 컨텍스트에서 호출되었으면 `window` | 함수 바깥 객체 컨텍스트. 전역 컨텍스트에서 호출되었으면 `window` |
| 메서드로서의 function 키워드의 함수 안    | 객체 컨텍스트                                                    | 객체 컨텍스트                                                    |
| 메서드로서의 화살표 함수 안               | `window`                                                         | `window`                                                         |

## prototype

> prototype은 fallback class이다. 객체 스스로가 정의하지 않은 프로퍼티나 메서드를 요구할 때 `__proto__` 프로퍼티에 들어가 찾아본다.
> `__proto__`에도 없으면 그 안의 또 `__proto__`에 들어가 찾아보고, 이런 식으로 `__proto__`가 null에 도달할 때까지 찾아본다.

<MessageBox title='__proto__가 null?' level='info'>
  Object의 `__proto__` 는 anonymous이고, anonymous의 `__proto__`는 Object이며, Object의 `__proto__`는 null이다.
  
  여기서부턴 내 추측인데, 생섬자 함수도 결국은 객체이기 때문에 `__proto__`가 존재하고, default로는 Object 프로토타입이 들어가는데 이 때, anonymous의 경우에는 Object의 프로토타입이기 때문에 순환 구조가 발생한다. 
  이를 막기 위해 예외적으로 anonymous의 Object는 다른 `__proto__`를 갖는 것 같다.
</MessageBox>

`.prototype`은 `__proto__`와는 다르다.

| `__proto__`                                     | `.prototype`                     |
| ----------------------------------------------- | -------------------------------- |
| 객체를 만든 생성자 함수에서 정의한 프로토타입   | 생성될 객체의 프로토타입을 정의. |
| 모든 자바스크립트 객체에 존재(생성자 함수 포함) | 생성자 함수에만 존재             |

```js
function User() {
  ...
}
User.prototype = {age: 10}

const user1 = new User()
console.log(user1.__proto__ === user1.prototype) //결과: true
console.log(user1.__proto__ === User.prototype) //결과: true
console.log(user1.__proto__ === User.__proto__) //결과: false
```

### 메서드 형태가 다르면 동작도 달라진다?

자바스크립트의 특이한 점이라고 한다면, 같은 의미임에도 표현하는 방식에 따라 동작이 미묘하게 달라진다는 것이다.

메서드를 작성하는 방법은 세 가지가 있다.

`Method shorthand`

```js
class Person {
  greet() {}
}
```

`Property Function`

```js
class Person {
  greet = function () {}
}
```

`Property Arrow Function`

```js
class Person {
  greet = () => {}
}
```

각 방식으로 함수를 정의한 뒤 객체를 만들고 console로 내부를 들여다보면 미묘하게 다르다는 것을 알 수 있다.

| Method Shorthand                                        | Property Function                                      | Property Arrow Function                              |
| ------------------------------------------------------- | ------------------------------------------------------ | ---------------------------------------------------- |
| prototype에 정의됨                                      | 프로퍼티에 정의됨                                      | 프로퍼티에 정의됨                                    |
| 객체를 여러 개 만들면 메모리 절약 등의 성능 이점이 있음 | 모든 객체마다 새로 생성되기 때문에 성능 이점은 없음    | 모든 객체마다 새로 생성되기 때문에 성능 이점은 없음  |
| event listener에 등록할 때 this는 DOM 객체가 되어 버림  | event listener에 등록할 때 this는 DOM 객체가 되어 버림 | event listener에 등록할 때 this는 객체 자신으로 유지 |

### 동적으로 프로퍼티와 프로토타입을 주입하는 방법

자바스크립트에서는 이미 생성된 객체에 프로토타입을 주입할 수 있다.

- `Object.defineProperty()`: 객체에 프로퍼티 주입.
- `Object.create()`: 객체 생성시에 프로토타입을 정의

```js
const student = Object.create(
  {
    printProgress: function () {
      console.log(this.progress)
    },
  },
  {
    name: 'hi',
  }
)

Object.defineProperty(student, 'progress', 0.8)
```

## 고급 함수

### Side Effects

`side effects`란 함수 내에서 외부에 영향을 끼칠 무언가를 하는 행위를 말한다.

HTTP 요청 보내거나, 전역 변수를 변경하는 등이다.

### 클로저

> 자바스크립트의 모든 함수는 클로저다.

클로저란 내부에서 사용하고 있는 모든 변수를 저장하는 함수이다.

함수 밖에서 정의된 변수더라도 내부에서 사용되고 있다면 저장한다.

## 비동기 - Promise & 콜백

비동기 코드의 가독성을 높이기 위해, `Promise` 객체를 지원한다.

> 비동기 코드가 nested되면 콜백 지옥(에너지파~!)이 발생한다.

`Promise` 생성자로 오래 걸리는 API를 래핑하고,

성공, 실패에 따라 `resolve`, `reject`를 호출하는 콜백을 등록한다.

`Promise`가 제공하는 `then`, `catch` 메서드가 콜백 결과를 처리하는 비동기 로직을 작성할 수 있게 제공한다.

```js
function getPosition() {
  const promise = new Promise((resolve, reject) => {
    navigator.geolocation.getCurrentPosition(
      (success) => {
        resolve(sucess)
      },
      (error) => {
        reject(error)
      }
    )
  })

  return promise
}

getPosition()
  .then((posData) => {
    console.log(posData)
  })
  .catch((err) => {
    console.error(err)
  })
```

### Promise의 상태

| `PENDING`                       | `RESOLVED`           | `REJECTED`        | `SETTLED`          |
| ------------------------------- | -------------------- | ----------------- | ------------------ |
| 프로미스가 작동 중              | 프로미스가 resolve됨 | 프로미스가 거부됨 | 프로미스 체인 종료 |
| 어떤 함수도 호출하지 않음(멈춤) | `then()` 호출        | `catch()` 호출    | `finally()` 호출   |

> `catch`나 `then` 블록 다음에 또 다른 `then` 블록이 있으면 프로미스가 `PENDING` 모드로 다시 들어간다.
> `then`과 `catch`는 항상 새로운 프로미스를 반환한다.
> `then` 내부에서 return하면 `resolve`로 처리.

<MessageBox title='`reject`가 발생하면 가장 가까운 `catch`를 찾을 때까지 이후 `then` 로직을 스킵한다.' level='info'>
  ```js
    getPosition()
      .then((posData) => {
        console.log(posData)
      })
      //some other async logic, which will be skipped if first promise throw an error by calling reject()
      .then()
      .then()
      .catch((err) => {
        console.error(err)
      })
  ```

그래서 catch는 promise 체인의 가장 마지막에 두는 것이 좋다.

</MessageBox>

### async/await와 raw promise

`async` 함수 내의 `await`를 걸지 않은 로직 또한 내부적으로 `then`으로 묶어버린다.

비동기 로직 전에 실행해야 할 로직이 함수 내에 있다면, raw promise 방식이 낫다.

```js
async function getGeoPosition() {
  try {
    const position = await getPosition()
  } catch (e) {
    console.error(e)
    return
  }

  // async/await 패턴에서는 위쪽 비동기 로직이 모두 완료된 후에야 호출된다.
  doSomethingImmediately()
}
```

### 여러 프로미스 처리하기

| `Promise.race()`                                          | `Promise.all()`                                                                                                                             | `promise.allSettled()`                                       |
| --------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------ |
| `Promise`의 `array`를 파라미터로 받는다.                  | `Promise`의 `array`를 파라미터로 받는다.                                                                                                    | `Promise`의 `array`를 파라미터로 받는다.                     |
| 가장 빨리 종료된(resolve, reject 상관없이) `promise` 반환 | 모든 `promise`가 **resolve** 될 때까지 기다린 뒤 `promise` 배열 반환. 하나라도 `reject`되면 `PENDING` 상태인 `promise`도 취소하고 반환한다. | 모든 `promise`가 종료될 때까지 기다린 뒤 `promise` 배열 반환 |


## String 다루기

- `lastIndexOf`
- `endsWith`
- `substring`

```javascript
const path = '/javascript/libraries/gsap summary.md'
const getFileName = (path) => {
  if (path.endsWith('.md') {
    return path
  }

  const lastIndex = path.lastIndexOf('/')
  return path.substring(lastIndex + 1)
}

//결과: gsam summary.md
getFileName(path)
```

## 객체 다루기

- 객체 안에 필드가 있는지 없는지 확인하는 방법

```javascript
const obj = {}
const field = 'someField'

if (field in obj) {
  // someField가 obj 객체에 필드로 있는 경우
}

if (obj[field] !== undefined) {
  // someField가 obj 객체에 필드로 있는 경우
}
```

## 스프레드 연산

- 배열은 스프레드 연산시 주의해야 한다.

```javascript
const obj = {}
const category = 'category'

//성공
if (obj[category] === undefined) {
  obj[category] = []
} else {
  obj[category].push(post)
}

//실패
obj[category] = [...obj[category], post]
```
