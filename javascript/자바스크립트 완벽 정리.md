---
summary: 자바스크립트를 처음부터 끝까지 정리합니다.
date: 2024-05-20
title-image: ''
---

## 자바스크립트 파싱 & 실행

chrome 기준으로 정리하면,

`V8`이라는 자바스크립트 엔진 내에는 인터프리터와 여러 컴파일러가 존재한다.

> 자바스크립트 코드 ➡️ AST ➡️ 바이트코드 ➡️ 실행

`V8` 내 컴파일러(`TurboFan` 아님)가 자바스크립트 코드에서 AST를 생성하면

인터프리터(`ignition`)가 AST를 바이트코드로 바꾸고, 실행한다.

그런데,

V8이 코드 실행을 모니터링하면서 최적화할 일부 코드를 찾았다면,

'최적화 컴파일러'(`TurboFan`, just in time compiler)를 통해 최적화가 적용된 머신코드로 변환한다.

최적화 실패시 다시 원래 바이트 코드로 복구한다.

[내용은 여기서 참고했습니다.](https://woo1031.vercel.app/article/v8-javascript-engine%EC%97%90%EC%84%9C-bytecode%EC%99%80-machine-code%EB%A5%BC-%ED%95%A8%EA%BB%98-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0)

<MessageBox title='just in compiler' level='info'>
  스크립트를 읽고, 머신 코드로 변환한 뒤 바로 실행하는 컴파일러.
</MessageBox>

## primitive와 reference 값

| `primitive`                                                               | `reference`                                                       |
| ------------------------------------------------------------------------- | ----------------------------------------------------------------- |
| Strings, Numbers, Booleans, null, undefined, Symbol                       | All other objects                                                 |
| 메모리 비용이 저렴                                                        | 메모리 비용이 비쌈                                                |
| 복사할 때 원본 변수를 바꿔도 복사된 변수값이 변하지 않음 (값 자체를 복사) | 복사할 때 원본 변수를 바꿔도 복사된 변수값이 변함 (포인터를 복사) |

<MessageBox title='primitive value가 객체처럼 사용될 수 있는 이유' level='info'>
  `primitive`도 객체처럼 `dot` 연산자를 사용하여 필드에 접근할 수 있는데,
  이는 `dot` 연산자 사용시 동적으로 `object`으로 변환되기 때문.
  
  그러나, dot 연산자를 사용한다고 해서 `reference`로 바뀌는 것은 아님.
</MessageBox>

## bind()

javascript의 `bind()` 함수는 함수 호출 전에 넘길 파라미터를 정해줄 수 있다.

### 예제

```js
const showResult = (message, result) => {
  console.log(message + ' ' + result)
}

const combine = function (resultHandler, operation, ...numbers) {
  let result = 0
  if (operation === 'Add') {
    for (const number of numbers) {
      result += number
    }
  } else if (operation === 'Subtract') {
    for (const number of numbers) {
      result -= number
    }
  }

  // bind()를 통해 The result of adding those numbers are:가 첫 번째 파라미터에 할당되었기 때문에, result는 두 번째 파라미터에 할당됨.
  resultHandler(result)
}

combine(
  showResult.bind('The result of adding those numbers are:'),
  'Add',
  1,
  5,
  -1,
  2
)
combine(
  showResult.bind('The result of subtracting those numbers are:'),
  'Subtract',
  1,
  5,
  -1,
  2
)

// 결과
// The result of adding those numbers are: 7
// The result of subtracting those numbers are: -7
```
