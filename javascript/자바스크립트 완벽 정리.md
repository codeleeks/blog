---
summary: 자바스크립트를 처음부터 끝까지 정리합니다.
date: 2024-05-20
title-image: ''
---

## 자바스크립트 파싱 & 실행

chrome 기준으로 정리하면,

`V8`이라는 자바스크립트 엔진 내에는 인터프리터와 여러 컴파일러가 존재한다.

> 자바스크립트 코드 ➡️ AST ➡️ 바이트코드 ➡️ 실행

`V8` 내 컴파일러(`TurboFan` 아님)가 자바스크립트 코드에서 AST를 생성하면

인터프리터(`ignition`)가 AST를 바이트코드로 바꾸고, 실행한다.

그런데,

V8이 코드 실행을 모니터링하면서 최적화할 일부 코드를 찾았다면,

'최적화 컴파일러'(`TurboFan`, just in time compiler)를 통해 최적화가 적용된 머신코드로 변환한다.

최적화 실패시 다시 원래 바이트 코드로 복구한다.

[내용은 여기서 참고했습니다.](https://woo1031.vercel.app/article/v8-javascript-engine%EC%97%90%EC%84%9C-bytecode%EC%99%80-machine-code%EB%A5%BC-%ED%95%A8%EA%BB%98-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0)

<MessageBox title='just in compiler' level='info'>
  스크립트를 읽고, 머신 코드로 변환한 뒤 바로 실행하는 컴파일러.
</MessageBox>

## primitive와 reference 값

| `primitive`                                                               | `reference`                                                       |
| ------------------------------------------------------------------------- | ----------------------------------------------------------------- |
| Strings, Numbers, Booleans, null, undefined, Symbol                       | All other objects                                                 |
| 메모리 비용이 저렴                                                        | 메모리 비용이 비쌈                                                |
| 복사할 때 원본 변수를 바꿔도 복사된 변수값이 변하지 않음 (값 자체를 복사) | 복사할 때 원본 변수를 바꿔도 복사된 변수값이 변함 (포인터를 복사) |

<MessageBox title='primitive value가 객체처럼 사용될 수 있는 이유' level='info'>
  `primitive`도 객체처럼 `dot` 연산자를 사용하여 필드에 접근할 수 있는데,
  이는 `dot` 연산자 사용시 동적으로 `object`으로 변환되기 때문.
  
  그러나, dot 연산자를 사용한다고 해서 `reference`로 바뀌는 것은 아님.
</MessageBox>

## bind()

javascript의 `bind()` 함수는 함수 호출 전에 넘길 파라미터를 정해줄 수 있다.

### 예제

```js
const showResult = (message, result) => {
  console.log(message + ' ' + result)
}

const combine = function (resultHandler, operation, ...numbers) {
  let result = 0
  if (operation === 'Add') {
    for (const number of numbers) {
      result += number
    }
  } else if (operation === 'Subtract') {
    for (const number of numbers) {
      result -= number
    }
  }

  // bind()를 통해 The result of adding those numbers are:가 첫 번째 파라미터에 할당되었기 때문에, result는 두 번째 파라미터에 할당됨.
  resultHandler(result)
}

combine(
  showResult.bind('The result of adding those numbers are:'),
  'Add',
  1,
  5,
  -1,
  2
)
combine(
  showResult.bind('The result of subtracting those numbers are:'),
  'Subtract',
  1,
  5,
  -1,
  2
)

// 결과
// The result of adding those numbers are: 7
// The result of subtracting those numbers are: -7
```

## this

```js
const obj = {
  info: { title: 'title!' },
  getFormattedTitle() {
    return this.info.title.toUpperCase()
  },
}

const { getFormattedTitle } = obj
getFormattedTitle() // 결과: undefined 에러 발생
obj.getFormattedTitle() // 결과: TITLE!
```

`this`를 `console`로 찍어보면 윈도우 객체가 나온다.

```bash
Window {window: Window, self: Window, document: document, name: '', location: Location, …}
```

`getFormattedTitle`를 호출하면 내부에 `this`가 윈도우 객체로 해석되기 때문에 `info` 필드에 접근할 수 없어 undefined 에러가 발생한다.

이럴 때 `bind`를 사용해 `getFormattedTitle`의 주인을 찾아준다.

```js
let { getFormattedTitle } = obj
const obj2 = { ...obj }
getFormattedTitle = getFormattedTitle.bind(obj2)
getFormattedTitle() // 결과: TITLE!
```

아니면 `call`를 사용할 수도 있다. `bind`는 새로운 함수를 반환하고, `call`은 바로 실행한다.

```js
let { getFormattedTitle } = obj
const obj2 = { ...obj }
getFormattedTitle.call(obj2) // 결과: TITLE!
```

### addEventListener의 callback 함수가 동작하는 방식

```js
const clickHandler = function () {
  console.log('clicked! - ', this)
}

const btnEl = document.querySelector('button')
btnEl.addEventListener('click', clickHandler)
```

콜백 함수의 this의 주인은 무엇일까?

브라우저는 콜백함수의 this를 이벤트를 발행한 DOM 객체에 `bind`한다.

따라서 `clickHandler`의 `this` 는 `btnEl`이다.

<MessageBox title='화살표 함수는 function 키워드의 함수와 다르다.' level='warning'>
  화살표 함수 안의 `this`는 함수 밖으로 나가서 정의된다고 보면 된다.
  그래서 function 키워드의 함수 안에서 사용되는 `this`는 `use strict`를 통해 window 객체가 아니라 undefined로 변경할 수 있지만,
  화살표 함수 안의 `this`는 변경할 수 없다.

화살표 함수의 `this`가 유용한 케이스도 있다.

```js
const members = {
  teamName: 'Blue Rockets',
  people: ['MAX', 'Manuel'],
  getTeamMembers() {
    this.people.forEach((p) => {
      console.log(this) //결과: members 객체
      console.log(p + ' - ' + this.teamName) //결과: MAX - Blue Rockets, Manuel - Blue Rockets
    })
  },
  // getTeamMembers() {
  //   this.people.forEach(function(p) {
  //     console.log(this) //결과: window 객체
  //     console.log(p + ' - ' + this.teamName) //결과: MAX - undefined, Manuel - undefined
  //   })
  // },
}
```

</MessageBox>

### 정리

`this`가 사용되는 케이스에 따라 그 의미를 아래 표로 정리한다.

| `this`가 사용되는 곳                      | 의미                                                             | 엄격 모드 적용시                                                 |
| ----------------------------------------- | ---------------------------------------------------------------- | ---------------------------------------------------------------- |
| 전역 컨텍스트                             | `window`                                                         | `window`                                                         |
| 전역 컨텍스트의 function 키워드의 함수 안 | `window`                                                         | `undefined`                                                      |
| 화살표 함수 안                            | 함수 바깥 객체 컨텍스트. 전역 컨텍스트에서 호출되었으면 `window` | 함수 바깥 객체 컨텍스트. 전역 컨텍스트에서 호출되었으면 `window` |
| 메서드로서의 function 키워드의 함수 안    | 객체 컨텍스트                                                    | 객체 컨텍스트                                                    |
| 메서드로서의 화살표 함수 안               | `window`                                                         | `window`                                                         |

## prototype

> prototype은 fallback class이다. 객체 스스로가 정의하지 않은 프로퍼티나 메서드를 요구할 때 `__proto__` 프로퍼티에 들어가 찾아본다.
> `__proto__`에도 없으면 그 안의 또 `__proto__`에 들어가 찾아보고, 이런 식으로 `__proto__`가 null에 도달할 때까지 찾아본다.

<MessageBox title='__proto__가 null?' level='info'>
  Object의 `__proto__` 는 anonymous이고, anonymous의 `__proto__`는 Object이며, Object의 `__proto__`는 null이다.
  
  여기서부턴 내 추측인데, 생섬자 함수도 결국은 객체이기 때문에 `__proto__`가 존재하고, default로는 Object 프로토타입이 들어가는데 이 때, anonymous의 경우에는 Object의 프로토타입이기 때문에 순환 구조가 발생한다. 
  이를 막기 위해 예외적으로 anonymous의 Object는 다른 `__proto__`를 갖는 것 같다.
</MessageBox>

`.prototype`은 `__proto__`와는 다르다.

| `__proto__`                                     | `.prototype`                     |
| ----------------------------------------------- | -------------------------------- |
| 객체를 만든 생성자 함수에서 정의한 프로토타입   | 생성될 객체의 프로토타입을 정의. |
| 모든 자바스크립트 객체에 존재(생성자 함수 포함) | 생성자 함수에만 존재             |

```js
function User() {
  ...
}
User.prototype = {age: 10}

const user1 = new User()
console.log(user1.__proto__ === user1.prototype) //결과: true
console.log(user1.__proto__ === User.prototype) //결과: true
console.log(user1.__proto__ === User.__proto__) //결과: false
```

### 메서드 형태가 다르면 동작도 달라진다?

자바스크립트의 특이한 점이라고 한다면, 같은 의미임에도 표현하는 방식에 따라 동작이 미묘하게 달라진다는 것이다.

메서드를 작성하는 방법은 세 가지가 있다.

`Method shorthand`

```js
class Person {
  greet() {}
}
```

`Property Function`

```js
class Person {
  greet = function () {}
}
```

`Property Arrow Function`

```js
class Person {
  greet = () => {}
}
```

각 방식으로 함수를 정의한 뒤 객체를 만들고 console로 내부를 들여다보면 미묘하게 다르다는 것을 알 수 있다.

| Method Shorthand                                        | Property Function                                      | Property Arrow Function                              |
| ------------------------------------------------------- | ------------------------------------------------------ | ---------------------------------------------------- |
| prototype에 정의됨                                      | 프로퍼티에 정의됨                                      | 프로퍼티에 정의됨                                    |
| 객체를 여러 개 만들면 메모리 절약 등의 성능 이점이 있음 | 모든 객체마다 새로 생성되기 때문에 성능 이점은 없음    | 모든 객체마다 새로 생성되기 때문에 성능 이점은 없음  |
| event listener에 등록할 때 this는 DOM 객체가 되어 버림  | event listener에 등록할 때 this는 DOM 객체가 되어 버림 | event listener에 등록할 때 this는 객체 자신으로 유지 |

### 동적으로 프로퍼티와 프로토타입을 주입하는 방법

자바스크립트에서는 이미 생성된 객체에 프로토타입을 주입할 수 있다.

- `Object.defineProperty()`: 객체에 프로퍼티 주입.
- `Object.create()`: 객체 생성시에 프로토타입을 정의

```js
const student = Object.create(
  {
    printProgress: function () {
      console.log(this.progress)
    },
  },
  {
    name: 'hi',
  }
)

Object.defineProperty(student, 'progress', .8)
```
