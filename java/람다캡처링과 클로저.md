---
summary: 람다캡처링과 클로저에 대해 정리합니다.
date: 2024-09-15
title-image: 'https://raw.githubusercontent.com/codeleeks/blog/codeleeks-images/java/%EC%9E%90%EB%B0%94%20%EA%B4%80%EB%A0%A8%20%EC%9A%A9%EC%96%B4%20%EC%A0%95%EB%A6%AC/title.png'
---

## 클로저

함수형 언어에서는 클로저라는 개념을 지원한다.
클로저는 여러 사이트에서 복잡하게 설명하고 있지만, 내가 이해한 것을 간단하게 적으면 '상태를 갖고 있는 함수'이다.
클로저는 함수가 호출되면 상태를 변경하기도 한다.

함수가 상태를 갖으면 호출할 때마다 상태를 변경하고, 변경된 상태로 특정한 동작을 수행할 수 있다.
예를 들면 초기값을 갖고, 함수를 호출할 때마다 그 값을 증가시키는 accumulator가 클로저이다.

```java
public IntUnaryOperator createAccumulator(int initialValue) {
  int value = initialValue;
  IntUnaryOperator accumulate = (x) -> { value += x; return value; };
  return accumulate;
}

//비즈니스 로직
public void buisnessA(IntUnaryOperator accumulate) {
  int id = accumulate();
  //... 중략
  cache.store(id, A);
}
```

객체 지향 입장에서 이해해 본다면, 메서드가 한 개뿐인 작은 객체라고 봐도 될 것이다.
그래서 자바에서는 `@FunctionalInterface`라는 어노테이션을 도입하여, 다른 함수형 언어에서 사용하는 클로저처럼 보이게 만들었다.

그렇지만, 자바는 클로저를 지원하지 않는다.
`@FunctionalInterface` 어노테이션은 람다표현식을 의미한다.

람다표현식: `(파라미터) -> { 코드(무언가를 리턴해야 함) }`

자바에서는 "상태를 갖고 있는 함수"를 쓸 수 있지만, 그 상태는 변경되선 안 된다.
더 정확히 말하면, 상태의 복사본을 변경할 수 있지만 상태 그 자체를 변경할 수 없게 컴파일 단계에서 막아놨다.

## 람다캡처링

```java
public IntUnaryOperator createAccumulator(int initialValue) {
  final int value = initialValue;
  IntUnaryOperator accumulate = (x) -> { int ret = value; ret++; return ret; };
  return accumulate;
}
```

자바에서 람다는 객체이다. 람다에서 사용하는 외부변수(위의 코드에서 value)는 람다라는 객체의 특정 멤버변수로 복사된다.
이를 람다캡처링이라고 한다.

람다 밖의 변수를 사용하는 것은 클로저와 유사하지만, 자바는 람다 밖의 변수가 불변해야 쓸 수 있게 제약을 걸었다.
그 이유는 안정성 때문이 아닐까 싶다.
자바 입장에서는 람다 밖의 변수 변경을 허용하지 않는 것이 더 안전한다고 보지 않았을까 싶다.
그래서 애초에 람다표현식을 지원할 때 람다캡처링 방식으로 구현한 것이 아닐까 싶다.

람다 밖 변수 변경을 지원하면, 동시성 관점에서 중요한 원칙인 "지역 변수는 스레드 세이프하다"를 포기해야 한다. 
